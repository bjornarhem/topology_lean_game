msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Wed Sep  3 19:03:24 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Levels.Subset.L01exact
msgid "The exact tactic"
msgstr ""

#: Game.Levels.Subset.L01exact
msgid "# Read this first\n"
"\n"
"Each level in this game involves proving a mathematical statement (the \"Goal\").\n"
"When you give a proof of this statement that\n"
"is accepted by Lean, we say that you have *closed* the goal.\n"
"\n"
"In this first level you're going to prove that if `x` belongs to the universe `U`,\n"
"`A` is a set of objects from `U`, and `x ∈ A`, then `x ∈ A`.  You should see\n"
"`U : Type`, `x : U`, and `A : Set U` under *Objects* in the pane to the right, and\n"
"`h : x ∈ A` under *Assumptions*.  The letter `h` here is called an *identifier*\n"
"for the assumption `x ∈ A`.\n"
"\n"
"You will prove goals in Lean using *tactics*.  The first tactic you're\n"
"going to learn is called `exact`, and it is used to close the goal.\n"
"You can close the goal by typing `exact` followed by a proof of the goal."
msgstr ""

#: Game.Levels.Subset.L01exact
msgid "Use `exact` to close a goal.  If some expression `t` is a proof of\n"
"the goal, then `exact t` will close the goal.\n"
"\n"
"Think of \"exact\" as meaning \"this is exactly what is needed to prove the goal.\""
msgstr ""

#: Game.Levels.Subset.L01exact
msgid "`x ∈ A` means that `x` is an element of `A`.  To enter the symbol `∈`, type\n"
"`\\mem` or `\\in`."
msgstr ""

#: Game.Levels.Subset.L01exact
msgid "Let $x$ be an object in the universe $U$, and let $A$ be a set whose elements\n"
"come from $U$.  Suppose that $x ∈ A$.  Then $x \\in A$."
msgstr ""

#: Game.Levels.Subset.L01exact
msgid "In order to complete this proof, type `exact h` in the text box\n"
"under the goal and click on \"Execute\" or hit the \"Return\" or \"Enter\" key."
msgstr ""

#: Game.Levels.Subset.L01exact
msgid "Congratulations! You have completed your first verified proof!\n"
"\n"
"Although this theorem was trivial, it illustrates an important fact: although we\n"
"called `h` an *identifier* for the assumption `x ∈ A`, it is also recognized by Lean\n"
"as a *proof* of the statement `x ∈ A`.  Any time you see `h : P`\n"
"listed as an assumption, where `P` is some statement, that means that Lean will\n"
"recognize `h` as a proof of the statement `P`.\n"
"\n"
"Remember that `exact` is a *tactic*. If you ever want information about the `exact` tactic,\n"
"you can click on `exact` in the list of tactics on the right.\n"
"\n"
"Note that, although `h` was a proof of the goal `x ∈ A`, you could not have closed the goal by\n"
"simply typing `h` in the text box.  Throughout this game, every move you make must invoke a tactic.\n"
"\n"
"Now click on \"Next\" to see a more interesting use of the `exact` tactic."
msgstr ""

#: Game.Levels.Subset.L02subhyp
msgid "A subset hypothesis"
msgstr ""

#: Game.Levels.Subset.L02subhyp
msgid "If `A` and `B` are sets, then we say that `A` is a *subset* of `B` if\n"
"every element of `A` is also an element of `B`.  The notation `A ⊆ B` means\n"
"that `A` is a subset of `B`.  (To enter the symbol `⊆`, type `\\sub`,\n"
"followed by a space.)\n"
"\n"
"If you have `h1 : A ⊆ B`, then `h1` is a proof that, if something is an element\n"
"of `A`, then it is also an element of `B`.  Thus, if you also have `h2 : x ∈ A`,\n"
"then you can apply `h1` to `h2` to conclude that `x ∈ B`.  To apply `h1` to `h2`,\n"
"you simply write `h1` followed by `h2`, with a space between them.  Thus, in\n"
"this situation, `h1 h2` is a proof of `x ∈ B`.\n"
"\n"
"See if you can use this to complete this level.  If you need a hint, click on\n"
"\"Show more help!\"."
msgstr ""

#: Game.Levels.Subset.L02subhyp
msgid "`A ⊆ B` means that `A` is a subset of `B`.  To enter the symbol `⊆`,\n"
"type `\\sub`."
msgstr ""

#: Game.Levels.Subset.L02subhyp
msgid "Suppose $A$ and $B$ are sets, $A \\subseteq B$, and $x \\in A$.\n"
"Then $x \\in B$."
msgstr ""

#: Game.Levels.Subset.L02subhyp
msgid "Since `h1 h2` is a proof of `x ∈ B`, you can\n"
"close the goal with `exact h1 h2`."
msgstr ""

#: Game.Levels.Subset.L02subhyp
msgid "This example is a better illustration of how the `exact` tactic is usually\n"
"used.  Often `exact` is followed by an expression that combines assumptions\n"
"to prove the goal.  In later levels, we will see other ways in which\n"
"assumptions can be combined to prove a goal.\n"
"\n"
"Note that in this proof, `h1` could be thought of as a function that can be\n"
"applied to a proof of any statement of the form `x ∈ A` to produce a proof\n"
"of `x ∈ B`.  Many proofs in Lean behave like functions."
msgstr ""

#: Game.Levels.Subset.L03have
msgid "The have tactic"
msgstr ""

#: Game.Levels.Subset.L03have
msgid "In this level, we have assumptions `h1 : A ⊆ B`, `h2 : B ⊆ C`, and `h3 : x ∈ A`.\n"
"As we saw in the last level, `h1 h3` is a proof that `x ∈ B`.  Unfortunately,\n"
"that is not the goal, so we can't use `exact h1 h3` to close the goal.\n"
"However, we can use the proof `h1 h3` to justify adding `h4 : x ∈ B` to our\n"
"list of assumptions.  To do that, we'll use a new tactic: `have`."
msgstr ""

#: Game.Levels.Subset.L03have
msgid "Use `have` to assert a statement that you can prove from your current\n"
"assumptions.  You must give the new assertion an identifier; be sure to\n"
"use an identifier that is different from those already in use.\n"
"\n"
"If some expression `t` is a proof of a statement `P`, and `h` is an\n"
"identifier that is not in use, then `have h : P := t` will add `h : P`\n"
"to the list of assumptions.\n"
"\n"
"There are two variations on the `have` tactic:\n"
"* Sometimes you want to assert a statement `P`, but the proof of `P` is too\n"
"difficult to be given in one line.  In that situation, you can simply write\n"
"`have h : P`.  Of course, you must still justify the assertion of `P`, so\n"
"the proof of `P` becomes your immediate goal.\n"
"Once the goal of proving `P` has been closed, you will be able to return to\n"
"your original goal, with `h : P` added to the assumption list.\n"
"* If you write `have h := t`, then Lean will try to figure out what statement\n"
"`P` is proven by the expression `t` and, if it can figure it out, it will fill\n"
"it in for you."
msgstr ""

#: Game.Levels.Subset.L03have
msgid "Suppose $A \\subseteq B$, $B \\subseteq C$, and $x \\in A$.  Then $x \\in C$."
msgstr ""

#: Game.Levels.Subset.L03have
msgid "To get started on this proof, type `have h4 : x ∈ B := h1 h3`\n"
"in the text box and click \"Execute\" or hit \"Return\" or \"Enter\".\n"
"Recall that you can enter the symbol `∈` by typing `\\mem` or `\\in`."
msgstr ""

#: Game.Levels.Subset.L03have
msgid "Notice that `«{h4}» : x ∈ B` has been added to the list of assumptions.\n"
"Can you complete the proof now?"
msgstr ""

#: Game.Levels.Subset.L03have
msgid "As we saw in the last level, `h2 «{h4}»` is now\n"
"a proof of the goal, so `exact h2 «{h4}»` will close the goal."
msgstr ""

#: Game.Levels.Subset.L03have
msgid "You can use the `have` tactic to add a new statement to your list of\n"
"assumptions, as long as you can justify it with a proof.  For further\n"
"information, click on `have` in the list of tactics on the right."
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "Implication"
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "If `P` and `Q` are statements, then `P → Q` means \"if P then Q\".\n"
"To enter the symbol `→`, type `\\imp` (short for \"implies\").\n"
"\n"
"The most straightforward way to prove a statement of the form `P → Q` is to assume that\n"
"`P` is true and then prove `Q`.  To do that, we'll need a new tactic: `intro`."
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "`P → Q` means \"if `P` then `Q`\".  You can enter the symbol `→` by typing `\\imp`.\n"
"\n"
"### If your goal is `P → Q`\n"
"\n"
"The tactic `intro h` will introduce the new assumption `h : P` into the proof, and set the goal\n"
"to be `Q`.  Be sure to use an identifier `h` that is not already being used to stand for\n"
"some assumption.\n"
"\n"
"### If you have an assumption `h : P → Q`\n"
"\n"
"If you also have `hP : P`, then `h hP` is a proof of `Q`."
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "Use `intro` to introduce either a new assumption or a new object into your proof.\n"
"\n"
"There are two situations in which you can use the `intro` tactic:\n"
"* If you are proving a statement of the form `P → Q`, then you can use\n"
"the tactic `intro h` to introduce the assumption `h : P` and set `Q` as the goal.  Be\n"
"sure to use an identifier that is not already in use.\n"
"* If you are proving a statement of the form `∀ x, P x`, where `P x` is some statement\n"
"about `x`, then you can use the tactic `intro x` to introduce a new object `x` into the proof.\n"
"Be sure to use a variable name that is not already in use.  The goal will then be `P x`.\n"
"\n"
"You can do multiple introductions in one step: for example, `intro x h` has the same\n"
"effect as doing `intro x` followed by `intro h`."
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "Let $x$ be an object from the universe $U$, and let $A$, $B$, and $C$ be sets\n"
"such that $A \\subseteq B$ and $x \\in B \\to x \\in C$.  Then $x \\in A → x \\in C$."
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "Since our goal in this level is the statement `x ∈ A → x ∈ C`, our first step for\n"
"this proof is to assume `x ∈ A`.  To introduce that assumption,\n"
"assigning it the identifier `h3`, type `intro h3`."
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "Notice that `«{h3}» : x ∈ A` is now listed under *Assumptions*, and your new goal is\n"
"`x ∈ C`."
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "As you saw in the previous level, you can now apply `h1` to `«{h3}»`\n"
"to justify asserting `x ∈ B`, using the `have` tactic."
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "Just as you were able to apply `h1` to `«{h3}»` in the last step,\n"
"you can now apply `h2` to `«{h4}»` to prove the goal."
msgstr ""

#: Game.Levels.Subset.L04imp
msgid "In general, if your goal has the form `P → Q`, then the tactic `intro h` will add `h : P` to\n"
"the list of assumptions and set `Q` to be the goal.  If you have assumptions\n"
"`h1 : P → Q` and `h2 : P`, then `h1 h2` is a proof of `Q`.  This is another example of a proof\n"
"acting like a function: a proof of `P → Q` can be thought of as a function which, when\n"
"applied to a proof of `P`, produces a proof of `Q`.\n"
"\n"
"As usual, for more information about the new tactic `intro`, you can click on `intro`\n"
"in the list of tactics on the right."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "Subset is reflexive"
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "How do you prove that one set is a subset of another?  To prove that `A ⊆ B`,\n"
"you have to show that if some object `x` is an element of `A`, then it is also\n"
"an element of `B`.  To do that, you'll have to introduce an object called `x` into\n"
"the proof.  The object denoted by `x` could be anything, so we say that it is\n"
"*arbitrary*.\n"
"\n"
"In this level, we start with a simple example of this kind of proof.  We're going\n"
"to show that if `A` is a set, then `A ⊆ A`."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "If you have `A : Set U`, then `Subset.refl A` is a proof of `A ⊆ A`.\n"
"In Mathlib, the name of this theorem is `Set.Subset.refl`."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "Let $A$ be any set.  Then $A \\subseteq A$."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "Our first step is to introduce an object `x` into the proof.  To do this, type `intro x`.\n"
"We have already seen that the `intro` tactic can be used to introduce a new *assumption* into a\n"
"proof.  This step illustrates a second use of `intro`: introducing a new *object* into a proof."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "Notice that `«{x}» : U` has been added to the list of objects, and\n"
"the goal has changed to `«{x}» ∈ A → «{x}» ∈ A`.  Fortunately, you already know how to prove\n"
"a goal of this form."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "Use `intro` again to introduce the assumption `«{x}» ∈ A`."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "The situation now should remind you of your first proof, in level 1 of this world."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "Notice that «{h}» is now a proof of the goal."
msgstr ""

#: Game.Levels.Subset.L05subref
msgid "The theorem you have proven in this level shows that the subset relation has\n"
"a property called *reflexivity*.  We have given the theorem the name `Subset.refl`.  You\n"
"will see it in the list of theorems on the right.  (This theorem is included in Lean's\n"
"mathematical library, Mathlib.  In Mathlib, the name of the theorem is `Set.Subset.refl`.\n"
"Many other set-theoretic theorems in this game have `Set.` at the beginnings of their names\n"
"in Mathlib.)"
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "Subset is transitive"
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "To start a proof, you should look first at the goal.\n"
"What needs to be done to prove the goal?\n"
"In this level, the goal is `A ⊆ C`.  What does that\n"
"tell you about how to proceed?"
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "If you have `h1 : A ⊆ B` and `h2 : B ⊆ C`, then `Subset.trans h1 h2` is a proof of `A ⊆ C`.\n"
"In Mathlib, the name of this theorem is `Set.Subset.trans`."
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "Suppose $A \\subseteq B$ and $B \\subseteq C$.  Then $A \\subseteq C$."
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "To get started, you'll need to introduce first\n"
"an object `x` and then the assumption that `x ∈ A`."
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "Does your situation now remind you of a previous level?"
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "First use `have` to assert that `«{x}» ∈ B`, and\n"
"then prove `«{x}» ∈ C`."
msgstr ""

#: Game.Levels.Subset.L06subtrans
msgid "The theorem you have proven in this level shows that the subset relation has\n"
"a property called *transitivity*.  We have given the theorem the name `Subset.trans`."
msgstr ""

#: Game.Levels.Subset
msgid "Subset World"
msgstr ""

#: Game.Levels.Subset
msgid "Welcome to Subset World! In this world you will learn about sets and\n"
"subsets, and you will also learn the basics of proving theorems in Lean.\n"
"\n"
"The elements of the sets in this world will come from a universe called `U`.\n"
"To specify that an\n"
"object `x` belongs to the universe `U`, we write `x : U`.  To specify\n"
"that `A` is a set of objects from `U`, we write `A : Set U`.  (The terminology used\n"
"in Lean is that `x` has *type* `U` and `A` has *type* `Set U`.)  To\n"
"say that `x` is an element of `A`, we write `x ∈ A`.  (You can enter\n"
"the symbol `∈` by typing `\\mem` or `\\in`, followed by a space.)\n"
"\n"
"You will prove theorems in this game by using tools called *tactics*.\n"
"The aim is to prove the theorem by applying tactics\n"
"in the right order.\n"
"\n"
"Let's learn some basic tactics. Click on \"Start\" below\n"
"to get started."
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "Proof by contradiction"
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "To work with complements, we'll need to understand negative statements--that is, statements\n"
"that say that something is *not* the case.\n"
"\n"
"If `P` is a statement, then `¬P` means \"it is not the case that P\".  To enter the symbol\n"
"`¬`, type `\\not`.\n"
"\n"
"A common method of proving a negative statement is *proof by\n"
"contradiction*: to prove a statement of the form `¬P`, you can assume that `P` is true\n"
"and then show that this assumption leads to a contradiction.  The tactic to use for this\n"
"kind of proof is `by_contra`."
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "If your goal is `¬P`, for some statement `P`, then the tactic\n"
"`by_contra h` will introduce the new assumption `h : P`, and set the\n"
"goal to be `False`.  If your goal is a statement `P` that is not a negative\n"
"statement, then `by_contra h` will introduce the new assumption\n"
"`h : ¬P`.\n"
"\n"
"To achieve your new goal, you will need to establish\n"
"`h1 : Q` and `h2 : ¬Q`, for some statement `Q`.  If you can do that,\n"
"then `h2 h1` will prove the goal `False`.  Notice that `h1 h2` will not be\n"
"recognized as a proof of `False`; the negative statement must come first."
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "`¬P` means \\\"it is not the case that P\\\".  To enter the symbol `¬`,\n"
"type `\\not`.\n"
"\n"
"### If your goal is `¬ P`\n"
"\n"
"You may be able to use the `push_neg` tactic to reexpress the goal as an equivalent\n"
"positive statement.  If not, then a good strategy is to use proof by contradiction.  The\n"
"tactic `by_contra h` will introduce the assumption `h : P`, and set the goal to be `False`.\n"
"\n"
"### If you have an assumption `h : ¬ P`\n"
"\n"
"You may be able to use the tactic `push_neg at h` to reexpress this assumption as an equivalent\n"
"positive statement.  Lean treats `¬ P` as meaning `P → False`, so if you also have `hP : P`,\n"
"then `h hP` will be a proof of `False`.  That means that if you are doing a proof by\n"
"contradiction, so your goal is `False`, then `exact h hP` will close the goal."
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "Suppose $x \\in A$ and $x \\notin B$.  Then $\\neg A \\subseteq B$."
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "For the theorem in this level, your goal is `¬A ⊆ B`.  To use proof by contradiction\n"
"in this proof, you must begin by introducing the assumption `h3 : A ⊆ B`.  To do that, type\n"
"`by_contra h3`"
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "Notice that the goal is now `False`.  To achieve that goal,\n"
"you must prove contradictory statements.  You can do that by\n"
"using `have` to assert `x ∈ B`, which will contradict `h2 : x ∉ B`."
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "`«{h3}» h1` is a proof of `x ∈ B`."
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "You can think of `h2 : x ∉ B` (which is shorthand for `h2 : ¬x ∈ B`)\n"
"as meaning \"if `x ∈ B` were true, then that would lead to a contradiction\"--in other\n"
"words, `x ∈ B → False`.\n"
"Applying this to your new assumption `«{h4}» : x ∈ B` will give the contradiction\n"
"you need.  In other words, `exact h2 «{h4}»` will close the goal."
msgstr ""

#: Game.Levels.Comp.L01contra
msgid "You can use the `by_contra` tactic in any proof to assume the\n"
"opposite of your goal.  But it is most useful when the goal\n"
"starts with the symbol `¬`.  After using the `by_contra` tactic,\n"
"your goal will be `False`.\n"
"\n"
"To complete a proof by contradiction, you must prove contradictory statements.\n"
"If your goal is `False` and you have assumptions `h1 : P` and `h2 : ¬P`, for\n"
"some statement `P`, then `exact h2 h1` will close the goal.  Note that `exact h1 h2` won't\n"
"work; you must list the negative statement first to establish a contradiction."
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "Definition of complement"
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "If you have `A : Set U`, then `Aᶜ` is defined to be the set of all objects in the universe `U`\n"
"that are not elements of `A`.  That means that if you also have `x : U`, then the statements\n"
"`x ∈ Aᶜ` and `x ∉ A` are equivalent.  We express this by saying that the statement\n"
"`x ∈ Aᶜ ↔ x ∉ A` is true.  (The symbol `↔` means \"if and only if\", and you can enter it\n"
"by typing `\\iff`.  You can enter the superscript `c` in the notation for the complement\n"
"of a set by typing `\\compl` or `\\^c`.)\n"
"\n"
"In this level, we're going to prove that the statement `x ∈ Aᶜ ↔ x ∉ A` is true, and to do\n"
"it we'll use a new tactic: `rfl`.  The `rfl` tactic can prove any statement of the form\n"
"`P ↔ Q` if `P` and `Q` are statements that are equivalent by virtue of the definitions of\n"
"the symbols occurring in them.  (We say in this case that `P` and `Q` are *definitionally\n"
"equivalent*.)  The `rfl` tactic can also prove statements of the form `X = Y`, if `X` and\n"
"`Y` are definitionally equal--that is, equal by virtue of definitions."
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "If your goal is a statement of the form `P ↔ Q`, and `P` and `Q` are definitionally\n"
"equivalent (that is, equivalent by virtue of the definitions of the symbols occurring in\n"
"them), then the `rfl` tactic will close the goal.  It will also close a goal of the form\n"
"`X = Y`, if `X` and `Y` are definitionally equal (that is, equal by virtue of definitions)."
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "If `A` is a of objects from the universe `U`, then `Aᶜ` is the complement of `A`; that is,\n"
"`Aᶜ` is the set of objects from `U` that are not elements of `A`.  You can enter the symbol `ᶜ`\n"
"by typing `\\compl` or `\\^c`."
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "`P ↔ Q` means \"P if and only if Q\".  You can enter the symbol `↔` by typing `\\iff`.\n"
"\n"
"### If your goal is `P ↔ Q`\n"
"\n"
"If `P` and `Q` are definitionally equivalent, then `rfl` will close the goal.\n"
"If you have `h1 : P → Q` and `h2 : Q → P`, then `Iff.intro h1 h2` is a proof of `P ↔ Q`,\n"
"so `exact Iff.intro h1 h2` will close the goal.\n"
"If you don't yet have proofs of `P → Q` and `Q → P`, then `apply Iff.intro` will set `P → Q`\n"
"and `Q → P` as your goals.  In this situation, the tactic `constructor` has the same effect as\n"
"`apply Iff.intro`.\n"
"\n"
"### If you have an assumption `h : P ↔ Q`\n"
"\n"
"Lean will recognize `h.mp` as a proof of `P → Q` and `h.mpr` as a proof of `Q → P`.  You may\n"
"also find it helpful to use `h` in the `rewrite` tactic."
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "If you have `A : Set U` and `x : U`, then `mem_compl_iff A x` is a proof of the statement\n"
"`x ∈ Aᶜ ↔ x ∉ A`.  In Mathlib, the name of this theorem is `Set.mem_compl_iff`."
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "Let $x$ be an object in the universe $U$, and let $A$ be a set whose elements\n"
"come from $U$.  Then $x \\in A^c \\leftrightarrow x \\notin A$."
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "The proof of the theorem in this level is very easy.\n"
"Since `x ∈ Aᶜ` and `x ∉ A` are definitionally equivalent, `rfl` will close the goal."
msgstr ""

#: Game.Levels.Comp.L02compdef
msgid "The name of the tactic `rfl` is short for \"reflexivity\", which is the property of\n"
"both `=` and `↔` that is the basis for the tactic.\n"
"\n"
"We have given the theorem proven in this level the name `mem_compl_iff`.  In the next level,\n"
"we will see how we can use it to prove theorems about complements."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "Complement subsets from subsets"
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "In the last level, you proved the theorem `mem_compl_iff`.  If you have `A : Set U` and `x : U`,\n"
"then `mem_compl_iff A x` is a proof of the statement `x ∈ Aᶜ ↔ x ∉ A`.\n"
"\n"
"You could think of the statement `x ∈ Aᶜ ↔ x ∉ A` as saying that if `x ∈ Aᶜ` occurs anywhere\n"
"in a proof, you can replace it with `x ∉ A`.  There is a tactic called `rewrite` that can be\n"
"used to perform such replacements.  You'll get to try out the `rewrite` tactic in this level."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "If the expression `t` is a proof of a statement of the form `P ↔ Q`, then the tactic\n"
"`rewrite [t]` will replace `P` anywhere that it occurs in the goal with `Q`.  If you want to\n"
"replace `Q` with `P`, use `rewrite [← t]`.  (Type `\\l` to enter the symbol `←`.)  To do the\n"
"replacement in an assumption `h`, use `rewrite [t] at h`.\n"
"\n"
"The `rewrite` tactic can also be used with equations.  If `t` is a proof of an equation\n"
"`p = q`, then `rewrite [t]` will replace `p` with `q` wherever it appears, and `rewrite [← t]`\n"
"will replace `q` with `p`.\n"
"\n"
"To do multiple replacements, one after another, put a list of proofs inside the brackets, like\n"
"this:  `rewrite [t1, t2]`."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "If you have `h : A ⊆ B`, then `compl_subset_compl_of_subset h` is a proof of `Bᶜ ⊆ Aᶜ`.\n"
"In Mathlib, the name of this theorem is `Set.compl_subset_compl_of_subset`."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "Suppose $A \\subseteq B$.  Then $B^c \\subseteq A^c$."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "As usual, to prove a subset statement you need to introduce both a new object `x` and\n"
"a new assumption `h2`.  You can do it in one step with `intro x h2`."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "Now `mem_compl_iff A «{x}»` is a proof of the statement `«{x}» ∈ Aᶜ ↔ «{x}» ∉ A`, which tells us\n"
"that we can reexpress the goal `«{x}» ∈ Aᶜ` as `«{x}» ∉ A`.  To do this reexpression,\n"
"use the tactic `rewrite [mem_compl_iff A «{x}»]`."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "The `rewrite` tactic is smart enough to figure out some things on its own.  If you\n"
"had just written `rewrite [mem_compl_iff]`, then Lean would have figured out how to apply the\n"
"theorem `mem_compl_iff` to get an equivalence that could be used to make a replacement in the goal.\n"
"In other words, it would have figured out that the theorem `mem_compl_iff` had to be applied to\n"
"`A` and `«{x}»`.\n"
"\n"
"Similarly, you can write `rewrite [mem_compl_iff] at «{h2}»` to write out the meaning of `«{h2}»`.  Lean\n"
"will figure out that in this case, `mem_compl_iff` has to be applied to `B` and `«{x}»`."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "Now your goal is a negative statement, so try proof by contradiction."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "This should remind you of the first level of this world.  To get a contradiction,\n"
"try to contradict `«{h2}» : «{x}» ∉ B`."
msgstr ""

#: Game.Levels.Comp.L03compsub
msgid "The `rewrite` tactic is often useful for writing out definitions.  For more information about\n"
"how it works, click on `rewrite` in the list of tactics on the right.  You can also use `rw`\n"
"instead of `rewrite`.  (There is actually a small difference between the tactics `rw` and\n"
"`rewrite`, but the difference won't concern us in this game.)\n"
"\n"
"You'll find the theorem you proved in this level listed as `compl_subset_compl_of_subset` in the list of\n"
"theorems on the right.  This theorem will be useful in the last level of this world."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "Complement of a complement"
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "How do we prove that two sets `A` and `B` are equal?  One way to do it is to use the theorem\n"
"`Subset.antisymm`.  This theorem is pre-defined in this game; you don't need to prove it.\n"
"If you have `h1 : A ⊆ B` and `h2 : B ⊆ A`, then\n"
"`Subset.antisymm h1 h2` is a proof of `A = B`.  The theorem `Subset.antisymm` says that the\n"
"subset relation has a property called *antisymmetry*.\n"
"\n"
"But what if you don't already know `A ⊆ B` and `B ⊆ A`?  In that case, you can use a new\n"
"tactic, `apply`.  If your goal is `A = B` and you write `apply Subset.antisymm`, then Lean will\n"
"figure out that the theorem `Subset.antisymm` could be applied to prove the goal, if only you had\n"
"proofs of `A ⊆ B` and `B ⊆ A`.  So it will set those *two* statements as goals.\n"
"\n"
"If your goal says that two sets are equal, a good way to begin is with\n"
"`apply Subset.antisymm`.  (Later we'll see a second approach to proving sets are equal.)\n"
"\n"
"This level also introduces another new tactic, `push_neg`."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "You can use the `apply` tactic to work backwards from the goal.  Suppose you think that you\n"
"will be able to use some theorem `t` to prove the goal.  In other words, you think there\n"
"is a proof of the goal of the form `t ?`, where the question mark needs to be replaced\n"
"with a proof of some statement `P` to which the theorem `t` must be applied.  The tactic\n"
"`apply t` will then set `P` as your goal.  If `t` must be applied to more than one proof to\n"
"establish the goal, then `apply t` will set all of the needed proofs as goals."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "If your goal is a negative statement, then the tactic `push_neg` will try to reexpress it as\n"
"an equivalent positive statement.  Similarly, if an assumption `h` is a negative\n"
"statement, then `push_neg at h` will try to reexpress `h`.  Here are some examples of\n"
"reexpressions performed by the `push_neg` tactic:\n"
"* `¬¬P` is converted to `P`.\n"
"* `¬(P ∨ Q)` is converted to `¬P ∧ ¬Q`.\n"
"* `¬(P ∧ Q)` is converted to `P → ¬Q`.\n"
"* `¬(P → Q)` is converted to `P ∧ ¬Q`.\n"
"* `¬∀ x, P x` is converted to `∃ x, ¬P x`.\n"
"* `¬∃ x, P x` is converted to `∀ x, ¬P x`."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "If you have `h1 : A ⊆ B` and `h2 : B ⊆ A`, then `Subset.antisymm h1 h2` is a proof of `A = B`.\n"
"In Mathlib, the name of this theorem is `Set.Subset.antisymm`."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "If `A` is a set, then `compl_compl A` is a proof of `Aᶜᶜ = A`."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "Suppose $A$ is a set.  Then $(A^c)^c = A$."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "In this level, your goal is `Aᶜᶜ = A`--that is, the complement of `Aᶜ` is equal to `A`.\n"
"So `apply Subset.antisymm` is a good way to start."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "Your immediate goal now is to prove that `Aᶜᶜ ⊆ A`.  Once you close that goal,\n"
"you'll be asked to prove the second goal, `A ⊆ Aᶜᶜ`."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "Now write out the definition of complement in `«{h1}»`."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "The assumption `«{h1}»` now says `«{x}» ∉ Aᶜ`, which means `¬«{x}» ∈ Aᶜ`.  It will be helpful to\n"
"write out the definition of complement again in this assumption."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "Now `«{h1}»` says `¬«{x}» ∉ A`, which means `¬¬«{x}» ∈ A`.  Of course, this can be simplified to\n"
"`«{x}» ∈ A`.  To perform this simplification, you'll need a new tactic, `push_neg`.  To simplify\n"
"the assumption `«{h1}»`, write `push_neg at «{h1}»`."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "The proof of the second goal is similar."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "There are two ways to complete the proof now.  Since your goal is a negative statement,\n"
"one natural strategy to use would be proof by contradiction.  A second possibility is to\n"
"imitate the approach in the first half: write out the meaning of complement again in the goal,\n"
"and then use the `push_neg` tactic to simplify the resulting double-negative goal.  Either\n"
"approach will work."
msgstr ""

#: Game.Levels.Comp.L04compcomp
msgid "The `push_neg` tactic can reexpress a number of different kinds of negative statements as\n"
"equivalent positive statements; use\n"
"`push_neg` to reexpress a negative goal, and `push_neg at h` to reexpress a negative assumption `h`.\n"
"We'll see many more uses of the `apply` tactic in this game.\n"
"For more details about the use of these tactics,\n"
"click on `push_neg` or `apply` under the list of tactics on the right.\n"
"\n"
"We have given this theorem the name `compl_compl`.  Both this theorem and the one in the previous\n"
"level will be useful in the next level."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "Complement subsets equivalence"
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "In this last level of Complement World, you'll prove a statement of the form `P ↔ Q`.  The most\n"
"useful theorem for this purpose is `Iff.intro`.  If you have `h1 : P → Q` and `h2 : Q → P`, then\n"
"`Iff.intro h1 h2` is a proof of `P ↔ Q`.  As we saw in the last level, that means you can start your\n"
"proof with `apply Iff.intro`.  Lean will set `P → Q` and `Q → P` as the goals that are needed\n"
"to complete the proof."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "If you have `h1 : P → Q` and `h2 : Q → P`, then `Iff.intro h1 h2` is a proof of `P ↔ Q`."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "Suppose $A$ and $B$ are sets.  Then $A \\subseteq B$ if and only if $B^c \\subseteq A^c$."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "For the proof in this level, `apply Iff.intro` will create the goals `A ⊆ B → Bᶜ ⊆ Aᶜ`\n"
"and `Bᶜ ⊆ Aᶜ → A ⊆ B`."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "Of course, you should begin by introducing the assumption\n"
"`h1 : A ⊆ B`."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "Fortunately, the theorem `compl_subset_compl_of_subset` can now be used to prove the goal.\n"
"(Click on `compl_subset_compl_of_subset` in the list of theorems on the right if you don't\n"
"remember what the theorem says.)"
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "`compl_subset_compl_of_subset «{h1}»` will prove the goal."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "The second goal is similar, but a little trickier."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "The theorem `compl_subset_compl_of_subset «{h1}»` doesn't prove the goal,\n"
"but it comes close.  Do you see what assertion it will justify?"
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "You can use `compl_subset_compl_of_subset «{h1}»` to\n"
"justify the assertion `Aᶜᶜ ⊆ Bᶜᶜ`."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "Fortunately, we can use the theorem `compl_compl` to prove `Aᶜᶜ = A` and\n"
"`Bᶜᶜ = B`, and those statements should get us from `«{h2}»` to the goal.\n"
"We have seen in previous levels that the `rewrite` tactic can be applied to a proof of a\n"
"statement of the form `P ↔ Q` to replace `P` with `Q`.  The tactic can also be applied to\n"
"equations: if `t` is a proof of an equation `p = q`, then `rewrite [t]` will\n"
"replace `p` with `q`."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "`rewrite [compl_compl A] at «{h2}»` will change `Aᶜᶜ` to\n"
"`A`, and `rewrite [compl_compl B] at «{h2}»` will change `Bᶜᶜ` to `B`.  In fact, you can do both\n"
"rewrites in one step:  `rewrite [compl_compl A, compl_compl B] at «{h2}»`."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "If your goal has the form `P ↔ Q`, then the tactic `constructor` will replace this\n"
"goal with the two goals `P → Q` and `Q → P`.  If your goal has the form `P ∧ Q`, then\n"
"`constructor` will replace this goal with the two goals `P` and `Q`.  There are other\n"
"situations in which the `constructor` tactic can be used, but these two are the ones\n"
"that are most relevant for the set theory game."
msgstr ""

#: Game.Levels.Comp.L05compsubiff
msgid "The proof in this level illustrates how previously proven theorems can be used in proofs.\n"
"\n"
"There is another tactic you can use if your goal has the form `P ↔ Q`.  In this situation,\n"
"the tactic `constructor` will have the same effect as `apply Iff.intro`; that is, it will\n"
"set `P → Q` and `Q → P` as goals to be proven."
msgstr ""

#: Game.Levels.Comp
msgid "Complement World"
msgstr ""

#: Game.Levels.Comp
msgid "If `A` is a set of objects from the universe `U`, then the *complement* of `A`,\n"
"denoted `Aᶜ`, is the set of all objects in the universe `U` that are *not*\n"
"elements of `A`.\n"
"\n"
"For example, if `U` consists of all people and `A` is the set of people who are more than\n"
"6 feet tall, then `Aᶜ` is the set of all people who are at most 6 feet tall.\n"
"\n"
"In this world, we'll see how to prove theorems about complements."
msgstr ""

#: Game.Levels.Inter.L01and
msgid "And"
msgstr ""

#: Game.Levels.Inter.L01and
msgid "To work with intersections, we'll need to understand the word \"and\".\n"
"\n"
"If `P` and `Q` are statements, then `P ∧ Q` means \"P and Q\".  To enter the\n"
"symbol `∧`, type `\\and`.  For the statement `P ∧ Q` to be true, `P` and `Q` must\n"
"both be true.  If you have `h : P ∧ Q`--that is, `h` is a proof of\n"
"the statement `P ∧ Q`--then in Lean, `h.left` is a proof of `P` and `h.right` is\n"
"a proof of `Q`.  That should be all you need to know to solve this level."
msgstr ""

#: Game.Levels.Inter.L01and
msgid "`P ∧ Q` means \"P and Q\".  To enter the symbol `∧`, type `\\and`.\n"
"\n"
"### If your goal is `P ∧ Q`\n"
"\n"
"If you have `hP : P` and `hQ : Q`, then `And.intro hP hQ` is a proof of `P ∧ Q`,\n"
"so `exact And.intro hP hQ` will close the goal.\n"
"If you don't yet have proofs of `P` and `Q`, then `apply And.intro` will set `P` and `Q`\n"
"as separate goals.  In this situation, the tactic `constructor` has the same effect as\n"
"`apply And.intro`.\n"
"\n"
"### If you have an assumption `h : P ∧ Q`\n"
"\n"
"Lean will recognize `h.left` as a proof of `P` and `h.right` as a proof of `Q`."
msgstr ""

#: Game.Levels.Inter.L01and
msgid "Suppose $x \\in A$ and $x \\in B$.  Then $x \\in A$."
msgstr ""

#: Game.Levels.Inter.L01and
msgid "Now we're ready to start proving theorems about intersections."
msgstr ""

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "Element of an intersection"
msgstr ""

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "In this level, we'll need to use the definition of \"intersection\".  The theorem that\n"
"expresses that definition is called `mem_inter_iff`.  If you have `x : U`, `A : Set U`, and\n"
"`B : Set U`, then `mem_inter_iff x A B` is a proof of the statement `x ∈ A ∩ B ↔ x ∈ A ∧ x ∈ B`.\n"
"As we saw in Complement World, that means that the tactic `rewrite [mem_inter_iff x A B]` can be\n"
"used to replace `x ∈ A ∩ B` in the goal with `x ∈ A ∧ x ∈ B`.  Usually Lean can figure out\n"
"`x`, `A`, and `B` on its own, so you can just write `rewrite [mem_inter_iff]`, and you can\n"
"use `rewrite [mem_inter_iff] at h` to do the replacement in an assumption `h` rather than\n"
"the goal.\n"
"\n"
"Like `mem_compl_iff`, `mem_inter_iff` can be proven by using the `rfl` tactic.  But we\n"
"won't ask you to prove it; it is pre-defined in this game.  To enter the symbol `∩`, you\n"
"can type `\\inter` or `\\cap`."
msgstr ""

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "If `A` and `B` are sets, then `A ∩ B` is the intersection of `A` and `B`.\n"
"To enter the symbol `∩`, type `\\inter` or `\\cap`."
msgstr ""

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "If you have `x : U`, `A : Set U`, and `B : Set U`, then `mem_inter_iff x A B` is a proof of the\n"
"statement `x ∈ A ∩ B ↔ x ∈ A ∧ x ∈ B`.\n"
"In Mathlib, the name of this theorem is `Set.mem_inter_iff`."
msgstr ""

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "Suppose $x \\in A ∩ B$.  Then $x \\in B$."
msgstr ""

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "To start on this proof, try writing out the meaning of intersection in `h`."
msgstr ""

#: Game.Levels.Inter.L02elt_inter_elt_right
msgid "Now your situation is similar to the previous level."
msgstr ""

#: Game.Levels.Inter.L03inter_sub_left
msgid "Intersection is a subset"
msgstr ""

#: Game.Levels.Inter.L03inter_sub_left
msgid "You should be able to combine ideas from previous levels to solve this one."
msgstr ""

#: Game.Levels.Inter.L03inter_sub_left
msgid "For any sets $A$ and $B$, $A \\cap B \\subseteq A$."
msgstr ""

#: Game.Levels.Inter.L03inter_sub_left
msgid "Since the goal is a subset statement, you should start by\n"
"introducing an object `x` and the assumption that `x ∈ A ∩ B`."
msgstr ""

#: Game.Levels.Inter.L03inter_sub_left
msgid "You probably used a step like `rewrite [mem_inter_iff] at h` in this proof.  That step is\n"
"actually optional.  Writing out the definition of intersection probably helps *you*\n"
"understand how to proceed with the proof, but *Lean* doesn't need to be told to\n"
"write out the definition.  It will do that on its own.  In other words, if you\n"
"have `h : x ∈ A ∩ B`, Lean will accept `h.left` as a proof of `x ∈ A`."
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "Proving a conjunction"
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "In this level we'll prove a statement of the form `P ∧ Q`.  To do this, we'll need\n"
"another theorem: `And.intro`.  If you have `h1 : P` and `h2 : Q`, then\n"
"`And.intro h1 h2` is a proof of `P ∧ Q`."
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "If you have `h1 : P` and `h2 : Q`, then `And.intro h1 h2` is a proof of `P ∧ Q`."
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "Suppose $x \\in A$ and $x \\in B$.  Then $x \\in A \\cap B$."
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "Writing out the meaning of intersection in the goal will help you see what to do to\n"
"complete this level."
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "Now you can use `And.intro` to prove the goal."
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "`exact And.intro h1 h2` will close the goal."
msgstr ""

#: Game.Levels.Inter.L04proveand
msgid "Once again, the use of `rewrite` was not really necessary.  You could prove this\n"
"theorem with the single step `exact And.intro h1 h2`."
msgstr ""

#: Game.Levels.Inter.L05subint
msgid "Subset of an intersection"
msgstr ""

#: Game.Levels.Inter.L05subint
msgid "Of course, you know by now how to start a proof that one set is a subset of another."
msgstr ""

#: Game.Levels.Inter.L05subint
msgid "Suppose $A \\subseteq B$ and $A \\subseteq C$.  Then $A \\subseteq B \\cap C$."
msgstr ""

#: Game.Levels.Inter.L05subint
msgid "Writing out the definition of intersection in the goal will help."
msgstr ""

#: Game.Levels.Inter.L05subint
msgid "If you had `hB : «{x}» ∈ B` and `hC : «{x}» ∈ C`, then `And.intro hB hC`\n"
"would prove the goal.  So there are two ways to proceed.  One possibility is to use\n"
"`have` to introduce the assumptions `«{x}» ∈ B` and `«{x}» ∈ C`--that is, if you can see\n"
"how to justify those statements!  Then you can use `And.intro` to prove the goal.\n"
"\n"
"The second possibility is to use the `apply` tactic.  Recall that if you write\n"
"`apply And.intro`, then Lean will figure out that the\n"
"theorem `And.intro` could be applied to prove the goal, if only you had proofs of\n"
"`«{x}» ∈ B` and `«{x}» ∈ C`.  So it will set those two statements as goals, to be proven\n"
"one after the other."
msgstr ""

#: Game.Levels.Inter.L05subint
msgid "Your immediate goal now is to prove that `«{x}» ∈ B`.  Once you close that goal,\n"
"you'll be asked to prove the second goal, `«{x}» ∈ C`."
msgstr ""

#: Game.Levels.Inter.L05subint
msgid "In general, if you think that some theorem `t` could be used to prove the goal, the tactic\n"
"`apply t` will work backwards from the goal, setting as new goals any hypotheses that are\n"
"needed for the application of the theorem `t`.\n"
"\n"
"If your goal has the form `P ∧ Q`, then the `constructor` tactic will have the same\n"
"effect as `apply And.intro`; that is, it will set `P` and `Q` as goals to be proven."
msgstr ""

#: Game.Levels.Inter.L06inter_sub_swap
msgid "Intersection subset of swap"
msgstr ""

#: Game.Levels.Inter.L06inter_sub_swap
msgid "In the next level we're going to prove that intersection is commutative; that is,\n"
"`A ∩ B = B ∩ A`.  As a warm-up, in this level we prove `A ∩ B ⊆ B ∩ A`."
msgstr ""

#: Game.Levels.Inter.L06inter_sub_swap
msgid "For any sets `A` and `B`, `inter_subset_swap A B` is a proof of\n"
"`A ∩ B ⊆ B ∩ A`."
msgstr ""

#: Game.Levels.Inter.L06inter_sub_swap
msgid "For any sets $A$ and $B$, $A \\cap B \\subseteq B \\cap A$."
msgstr ""

#: Game.Levels.Inter.L06inter_sub_swap
msgid "It will help you see how to proceed if you\n"
"write out the definition of intersection in both the assumption «{h}» and the goal.\n"
"Using the `rewrite` tactic isn't necessary; you can just do the rewriting in\n"
"your head rather than asking Lean to do it.  But if it helps you to figure out the\n"
"proof, go ahead and use the `rewrite` tactic."
msgstr ""

#: Game.Levels.Inter.L06inter_sub_swap
msgid "Now `And.intro «{h}».right «{h}».left` proves the goal."
msgstr ""

#: Game.Levels.Inter.L06inter_sub_swap
msgid "We have given this theorem the name `inter_subset_swap`.  Thus, from now on, for\n"
"any sets `A` and `B`, `inter_subset_swap A B` is a proof of `A ∩ B ⊆ B ∩ A`."
msgstr ""

#: Game.Levels.Inter.L07inter_comm
msgid "Intersection is commutative"
msgstr ""

#: Game.Levels.Inter.L07inter_comm
msgid "As we saw in Complement World, a good first step when your goal is an equation between\n"
"sets is `apply Subset.antisymm`.  For the theorem in this level, that will leave you with\n"
"two goals: `A ∩ B ⊆ B ∩ A` and `B ∩ A ⊆ A ∩ B`.  Fortunately, you can prove *both* of these\n"
"goals by using the theorem `inter_subset_swap` from the last level."
msgstr ""

#: Game.Levels.Inter.L07inter_comm
msgid "For any sets `A` and `B`, `inter_comm A B` is a proof of the\n"
"statement `A ∩ B = B ∩ A`.  In Mathlib, the name of this theorem is `Set.inter_comm`."
msgstr ""

#: Game.Levels.Inter.L07inter_comm
msgid "For any sets $A$ and $B$, $A \\cap B = B \\cap A$."
msgstr ""

#: Game.Levels.Inter.L07inter_comm
msgid "We'll prove one more property of intersections in the next level."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "Intersection is associative"
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "Our goal in this level is again an equation between sets.  In previous proofs of this kind,\n"
"we've started with the tactic `apply Subset.antisymm`, and that would work here as well.\n"
"But we're going to try out an alternative: the tactic `ext`.  This tactic applies the principle\n"
"of *extensionality* for sets, which says that if\n"
"two sets have exactly the same elements, then they are equal."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "For any sets `A`, `B`, and `C`, `inter_assoc A B C` is a proof of the\n"
"statement `(A ∩ B) ∩ C = A ∩ (B ∩ C)`.  Im Mathlib, the name of this theorem is `Set.inter_assoc`."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "If your goal is `A = B`, where `A` and `B` are sets, then the tactic `ext x` will introduce\n"
"a new arbitrary object `x` into the proof and set the goal to be `x ∈ A ↔ x ∈ B`."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "For any sets $A$, $B$, and $C$, $(A \\cap B) \\cap C = A \\cap (B \\cap C)$."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "Notice that Lean has written the goal as `A ∩ B ∩ C = A ∩ (B ∩ C)`, with no\n"
"parentheses on the left.  When an intersection of more than two sets is written\n"
"without parentheses, Lean groups the intersections to the left, so this means\n"
"`(A ∩ B) ∩ C = A ∩ (B ∩ C)`.\n"
"\n"
"To start this proof, use the tactic `ext x`."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "Notice that Lean has introduced the new object `«{x}» : U` into the proof, and\n"
"your goal is now `«{x}» ∈ A ∩ B ∩ C ↔ «{x}» ∈ A ∩ (B ∩ C)`.  Proving this goal will show that\n"
"`A ∩ B ∩ C` and `A ∩ (B ∩ C)` have exactly the same elements, and by the principle of\n"
"extensionality, that will show that the sets are equal."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "Since your goal is an \"if and only if\" statement, a good next step\n"
"is `apply Iff.intro`."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "Since your goal is an \"if-then\" statement, a good next step\n"
"is `intro h1`."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "If you're stuck at this point,\n"
"it may help you see how to proceed if you separate\n"
"out the first half of `«{h1}»` as a separate assumption.\n"
"You can do this with `have hAB : «{x}» ∈ A ∩ B := «{h1}».left`."
msgstr ""

#: Game.Levels.Inter.L08inter_assoc
msgid "Well done!  You're ready to move on to Union World."
msgstr ""

#: Game.Levels.Inter
msgid "Intersection World"
msgstr ""

#: Game.Levels.Inter
msgid "If `A` and `B` are sets, then the *intersection* of `A` and `B`, denoted\n"
"`A ∩ B`, is the set of elements that the two sets have in common.  In other words,\n"
"for an object to be an element of `A ∩ B`, it must be an element of both `A` and `B`.\n"
"\n"
"For example, if `A` is the set of all round things, and `B` is the set of all red things,\n"
"then `A ∩ B` is the set of all round red things.\n"
"\n"
"In this world you'll prove some basic properties of intersections of sets."
msgstr ""

#: Game.Levels.Union.L01or
msgid "Or"
msgstr ""

#: Game.Levels.Union.L01or
msgid "For working with unions, the important logical word is \"or\".\n"
"\n"
"If `P` and `Q` are statements, then `P ∨ Q` means \"P or Q or both\".  To enter the\n"
"symbol `∨`, type `\\or`.  For the statement `P ∨ Q` to be true, either `P` or `Q` must\n"
"be true.  This gives us two ways to prove a statement of this form.  If you have\n"
"`h : P`, then `Or.inl h` can be used to prove `P ∨ Q`.  If you have `h : Q`, then\n"
"`Or.inr h` proves `P ∨ Q`."
msgstr ""

#: Game.Levels.Union.L01or
msgid "`P ∨ Q` means \"P or Q or both\".  To enter the symbol `∨`, type `\\or`.\n"
"\n"
"### If your goal is `P ∨ Q`\n"
"\n"
"If you have `hP : P`, then `Or.inl hP` is a proof of `P ∨ Q`, so `exact Or.inl hP`\n"
"will close the goal.  Similarly, if you have `hQ : Q`, then `Or.inr hQ` is a proof\n"
"of `P ∨ Q`.  If you don't have a proof of either `P` or `Q`, but you think you know\n"
"which one is true, then you can use `apply Or.inl` to set the goal to be `P`, or\n"
"`apply Or.inr` to set the goal to be `Q`.  Alternatively, the tactic `left` will have\n"
"the same effect as `apply Or.inl`, and `right` will have the same effect as\n"
"`apply Or.inr`.\n"
"\n"
"### If you have an assumption `h : P ∨ Q`\n"
"\n"
"A good strategy would be to use proof by cases.  The tactic `rcases h with hP | hQ`\n"
"will break the proof into two cases.  In case 1, the assumption `h` is replaced by\n"
"`hP : P `, and in case 2 it is replaced by `hQ : Q`.  In both cases, you must prove\n"
"the goal."
msgstr ""

#: Game.Levels.Union.L01or
msgid "If you have `h : P`, then `Or.inl h` can be used as a proof of `P ∨ Q`, for\n"
"any statement `Q`."
msgstr ""

#: Game.Levels.Union.L01or
msgid "If you have `h : Q`, then `Or.inr h` can be used as a proof of `P ∨ Q`, for\n"
"any statement `P`."
msgstr ""

#: Game.Levels.Union.L01or
msgid "Suppose $x \\in A$, and $B$ is any set.  Then $x \\in A ∨ x ∈ B$."
msgstr ""

#: Game.Levels.Union.L01or
msgid "`Or.inl h` is a proof of the goal."
msgstr ""

#: Game.Levels.Union.L01or
msgid "Now we're ready to start proving theorems about unions."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "Subset of a union"
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "As with complements and intersections, one of the key tools for proving theorems about unions\n"
"is a theorem stating the definition.  If you have `x : U`, `A : Set U`, and `B : Set U`,\n"
"then `mem_union x A B` is a proof of the statement `x ∈ A ∪ B ↔ x ∈ A ∨ x ∈ B`.\n"
"That means you can use `rewrite [mem_union]` to write out the definition of\n"
"`x ∈ A ∪ B` if it appears in any assumption or the goal.  (The similar theorem about intersections\n"
"was called `mem_inter_iff`.  Why isn't this one called `mem_union_iff`?  I don't know.  The\n"
"naming of theorems in Lean is systematic, but there are occasional surprises.)"
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "If `A` and `B` are sets, then `A ∪ B` is the union of `A` and `B`.\n"
"To enter the symbol `∪`, type `\\union`."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "If you have `x : U`, `A : Set U`, and `B : Set U`, then `mem_union x A B` is a proof of the\n"
"statement `x ∈ A ∪ B ↔ x ∈ A ∨ x ∈ B`.  In Mathlib, the name of this theorem is `Set.mem_union`."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "Suppose $A$ and $B$ are sets.  Then $B \\subseteq A \\cup B$."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "Your goal is a subset statement.\n"
"That should tell you how to get started."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "Writing out the definition of union in the goal should help you see how to proceed."
msgstr ""

#: Game.Levels.Union.L02subunion
msgid "Next, we'll see how to prove that a union is a subset of another set."
msgstr ""

#: Game.Levels.Union.L03cases
msgid "Proof by cases"
msgstr ""

#: Game.Levels.Union.L03cases
msgid "In this proof, we'll need a new proof technique: proof by cases.  And we'll need a new\n"
"tactic to implement that technique in Lean: `rcases`."
msgstr ""

#: Game.Levels.Union.L03cases
msgid "If `h` is a proof of a statement of the form `P ∨ Q`, then the tactic\n"
"`rcases h with h1 | h2` will break your proof into cases.  In case 1, you'll have the new\n"
"assumption `h1 : P`, and in case 2 you'll have `h2 : Q`.  In both cases you have to prove\n"
"the original goal.\n"
"\n"
"The `rcases` tactic has other uses.  In particular, it can be applied to proofs of statements\n"
"that do not have the form `P ∨ Q`.  However, we will not discuss these other uses of the\n"
"`rcases` tactic in this game."
msgstr ""

#: Game.Levels.Union.L03cases
msgid "Suppose $A \\subseteq C$ and $B \\subseteq C$.  Then $A \\cup B \\subseteq C$."
msgstr ""

#: Game.Levels.Union.L03cases
msgid "Of course, to start a subset proof you need to introduce an object `x` and an\n"
"assumption `h3`."
msgstr ""

#: Game.Levels.Union.L03cases
msgid "To understand the logic of this proof, it will help to write out the definition\n"
"of union in `«{h3}»`."
msgstr ""

#: Game.Levels.Union.L03cases
msgid "Now the assumption `«{h3}»` is an \"or\" statement.  The easiest way to use such an\n"
"assumption is to break your proof into cases.  To do this in Lean, use the tactic\n"
"`rcases «{h3}» with «{h3}»A | «{h3}»B`."
msgstr ""

#: Game.Levels.Union.L03cases
msgid "Now you have *two* goals.  For the first, the assumption `«{x}» ∈ A ∨ «{x}» ∈ B` has been\n"
"replaced with `«{x}» ∈ A`, and for the second it has been replaced with `«{x}» ∈ B`.  In both\n"
"cases, you must prove `«{x}» ∈ C`.  The two identifiers after `with` in the `rcases` tactic\n"
"are used as the identifiers of the new assumptions in the two cases."
msgstr ""

#: Game.Levels.Union.L03cases
msgid "Note that Lean also has a `cases` tactic, but the syntax is a little more complicated.\n"
"That's why we have chosen to use the `rcases` tactic.\n"
"\n"
"The `rcases` tactic has other uses.  However, in this game we will be using it only with\n"
"assumptions that are \"or\" statements, to break the proof into cases."
msgstr ""

#: Game.Levels.Union.L04union_sub_swap
msgid "Union subset of swap"
msgstr ""

#: Game.Levels.Union.L04union_sub_swap
msgid "In the next level we're going to prove that union is commutative; that is,\n"
"`A ∪ B = B ∪ A`.  We're going to imitate the approach we used in Intersection World\n"
"to prove that intersection is commutative.  We begin by proving `A ∪ B ⊆ B ∪ A`."
msgstr ""

#: Game.Levels.Union.L04union_sub_swap
msgid "For any sets `A` and `B`, `union_sub_swap A B` is a proof of\n"
"`A ∪ B ⊆ B ∪ A`."
msgstr ""

#: Game.Levels.Union.L04union_sub_swap
msgid "For any sets $A$ and $B$, $A \\cup B \\subseteq B \\cup A$."
msgstr ""

#: Game.Levels.Union.L04union_sub_swap
msgid "It will help you see how to proceed if you\n"
"write out the definition of union in both the assumption `«{h}»` and the goal."
msgstr ""

#: Game.Levels.Union.L04union_sub_swap
msgid "The form of the assumption `«{h}»` now suggests proof by cases."
msgstr ""

#: Game.Levels.Union.L04union_sub_swap
msgid "You'll be able to use the theorem `union_subset_swap` in the next level to prove\n"
"that union is commutative."
msgstr ""

#: Game.Levels.Union.L05union_comm
msgid "Union is commutative"
msgstr ""

#: Game.Levels.Union.L05union_comm
msgid "If you start your proof with `apply Subset.antisymm`, then you'll be able to use\n"
"the theorem `union_subset_swap` that you proved in the last level."
msgstr ""

#: Game.Levels.Union.L05union_comm
msgid "For any sets `A` and `B`, `union_comm A B` is a proof of the\n"
"statement `A ∪ B = B ∪ A`.  In Mathlib, the name of this theorem is `Set.union_comm`."
msgstr ""

#: Game.Levels.Union.L05union_comm
msgid "For any sets $A$ and $B$, $A \\cup B = B \\cup A$."
msgstr ""

#: Game.Levels.Union.L05union_comm
msgid "Next we'll prove the associative law for unions."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "Union is associative"
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "Here's an idea that you may find helpful for this proof:\n"
"If you're proving an \"or\" statement and you think you'll be\n"
"able to prove either the left or right side of the statement, then `apply Or.inl` or\n"
"`apply Or.inr` will set the goal to be the left or right side.  Alternatively, the tactic\n"
"`left` has the same effect as `apply Or.inl`, and `right` has the same effect as\n"
"`apply Or.inr`.\n"
"\n"
"You can start this proof with either `ext x` or `apply Subset.antisymm`."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "For any sets `A`, `B`, and `C`, `union_assoc A B C` is a proof of the\n"
"statement `(A ∪ B) ∪ C = A ∪ (B ∪ C)`.  In Mathlib, the name of this theorem is `Set.union_assoc`."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "For any sets $A$, $B$, and $C$, $(A \\cup B) \\cup C = A \\cup (B \\cup C)$."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "Notice that, as with intersections, Lean groups unions to the left, so\n"
"`A ∪ B ∪ C` means `(A ∪ B) ∪ C`."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "Do you know which half of the goal you're going to prove now?"
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "If your goal has the form `P ∨ Q`, then the tactic `left` will set your goal to be `P`.\n"
"There are other situations in which the `left` tactic can be used, but this is the one\n"
"that is most relevant for the set theory game."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "If your goal has the form `P ∨ Q`, then the tactic `right` will set your goal to be `Q`.\n"
"There are other situations in which the `right` tactic can be used, but this is the one\n"
"that is most relevant for the set theory game."
msgstr ""

#: Game.Levels.Union.L06union_assoc
msgid "You've mastered reasoning about complements, intersections, and unions.  In the next world,\n"
"we'll start mixing them up!"
msgstr ""

#: Game.Levels.Union
msgid "Union World"
msgstr ""

#: Game.Levels.Union
msgid "If `A` and `B` are sets, then the *union* of `A` and `B`, denoted\n"
"`A ∪ B`, is the set you get by throwing all the elements of `A` and `B`\n"
"together into one set.  In other words, for an object to be an element of\n"
"`A ∪ B`, it must be an element of either `A` or `B`, or both.\n"
"\n"
"For example, if `A` is the set of all people under 30, and `B` is the set of\n"
"all people over 20, then `A ∪ B` is the set of all people.\n"
"\n"
"In this world you'll prove some basic properties of unions of sets."
msgstr ""

#: Game.Levels.Combo.L01compunion
msgid "Complement of a union"
msgstr ""

#: Game.Levels.Combo.L01compunion
msgid "There is more than one way to do the proof in this level.  Since the proof involves complements of\n"
"sets, negative statements will arise in the course of the proof.  This suggests two possible techniques.\n"
"You may be able to use the `push_neg` tactic to reexpress some negative statements as equivalent\n"
"positive statements.  And you may find proof by contradiction useful."
msgstr ""

#: Game.Levels.Combo.L01compunion
msgid "For any sets `A` and `B`, `compl_union A B` is a proof of the\n"
"statement `(A ∪ B)ᶜ = Aᶜ ∩ Bᶜ`.  In Mathlib, the name of this theorem is `Set.compl_union`."
msgstr ""

#: Game.Levels.Combo.L01compunion
msgid "For any sets $A$ and $B$, $(A \\cup B)^c = A^c \\cap B^c$."
msgstr ""

#: Game.Levels.Combo.L02compint
msgid "Complement of an intersection"
msgstr ""

#: Game.Levels.Combo.L02compint
msgid "Of course, you could start the proof in this level with either `ext x` or `apply Subset.antisymm`.\n"
"But there is a shorter solution: you can use\n"
"the theorem from the previous level (`compl_union`) to prove the\n"
"theorem in this level.\n"
"\n"
"The trick to get started on this proof is to rewrite `Aᶜ ∪ Bᶜ` as `(Aᶜ ∪ Bᶜ)ᶜᶜ`.  As you\n"
"know, `compl_compl (Aᶜ ∪ Bᶜ)` is a proof of the theorem `(Aᶜ ∪ Bᶜ)ᶜᶜ = Aᶜ ∪ Bᶜ`, and therefore\n"
"`rewrite [compl_compl (Aᶜ ∪ Bᶜ)]` could be used to rewrite `(Aᶜ ∪ Bᶜ)ᶜᶜ` as `Aᶜ ∪ Bᶜ`; but we\n"
"want to go in the opposite direction, rewriting `Aᶜ ∪ Bᶜ` as `(Aᶜ ∪ Bᶜ)ᶜᶜ`. To do that, use\n"
"`rewrite [← compl_compl (Aᶜ ∪ Bᶜ)]`. (To enter the left-pointing arrow, type `\\l`.)"
msgstr ""

#: Game.Levels.Combo.L02compint
msgid "For any sets `A` and `B`, `compl_inter A B` is a proof of the\n"
"statement `(A ∩ B)ᶜ = Aᶜ ∪ Bᶜ`.  In Mathlib, the name of this theorem is `Set.compl_inter`."
msgstr ""

#: Game.Levels.Combo.L02compint
msgid "For any sets $A$ and $B$, $(A \\cap B)^c = A^c \\cup B^c$."
msgstr ""

#: Game.Levels.Combo.L02compint
msgid "Do you see how you can now use the theorem from the previous level?"
msgstr ""

#: Game.Levels.Combo
msgid "Combination World"
msgstr ""

#: Game.Levels.Combo
msgid "In this world you'll prove theorems combining complements, intersections, and unions.  For\n"
"the most part, we'll leave you on your own to figure out these proofs."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "Family intersection is subset"
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "In mathematical writing, the intersection of the family $F$ is usually denoted $\\bigcap F$.\n"
"In Lean, the intersection of a family `F` is denoted `⋂₀ F`.  (You can enter the symbol\n"
"`⋂₀` by typing `\\I0`.)\n"
"\n"
"Suppose we have `F : Set (Set U)` and `x : U`.  Then `x ∈ ⋂₀ F` means that for every set `t`, if\n"
"`t` is in `F`, then `x ∈ t`.  To write this statement in Lean, we write `∀ t, t ∈ F → x ∈ t`.\n"
"Lean abbreviates this statement as `∀ t ∈ F, x ∈ t`.\n"
"The symbol `∀` is called the *universal quantifier*, and you can enter it in Lean by typing\n"
"`\\forall`.  Note that `∀ t, t ∈ F → x ∈ t` means `∀ t, (t ∈ F → x ∈ t)`, not\n"
"`(∀ t, t ∈ F) → x ∈ t`.  In other words, Lean interprets the universal quantifier as applying\n"
"to the entire rest of the statement.  If you want it to apply to less, you have to\n"
"use parentheses to indicate that.\n"
"\n"
"As with other set theory operations, we have a theorem that expresses this definition.  Lean will\n"
"recognize `mem_sInter` as a proof of any statement of the form `x ∈ ⋂₀ F ↔ ∀ t ∈ F, x ∈ t`.\n"
"\n"
"In this level, you'll try out these ideas."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "`⋂₀ F` is the intersection of the family of sets `F`.  To enter the symbol `⋂₀`, type `\\I0`."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "If `P x` represents a statement about an unspecified object `x`, then `∀ x, P x` means\n"
"\"for all `x`, `P x` is true\".  To enter the symbol `∀`, type `\\forall`.\n"
"\n"
"### If your goal is `∀ x, P x`\n"
"\n"
"The tactic `intro t` will introduce a new object `t` into the proof, and set the goal to be `P t`.\n"
"Be sure to use a variable `t` that is not already being used to stand for some object.\n"
"\n"
"### If you have an assumption `h : ∀ x, P x`\n"
"\n"
"If `a` stands for some object, then `h a` is a proof of `P a`.  Note that `a` must be the right\n"
"*type* of object.  For example, if `x` stands for an object in the universe `U`, then `a` must\n"
"have type `U`; if `x` stands for a set of objects from the universe `U`, then `a` must have\n"
"type `Set U`."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "Lean will recognize `mem_sInter` as a proof of any statement of the form\n"
"`x ∈ ⋂₀ F ↔ ∀ t ∈ F, x ∈ t`.  In Mathlib, the name of this theorem is `Set.mem_sInter`."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "Suppose $F$ is a family of sets and $A \\in F$.  Then $\\bigcap F \\subseteq A$."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "As usual, you may find it helpful to use the `rewrite` tactic to write out the\n"
"definition of `«{x}» ∈ ⋂₀ F`, using the theorem `mem_sInter`."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "Remember that `«{h2}» : ∀ t ∈ F, «{x}» ∈ t` is an abbreviation for\n"
"`«{h2}» : ∀ t, t ∈ F → «{x}» ∈ t`.  Since `∀` means \"for all\", `«{h2}»` can be applied to any\n"
"set--that is, we can plug in any set for `t` in `«{h2}»`.\n"
"In particular, applying it to the set `A`, we can conclude that `A ∈ F → «{x}» ∈ A`.\n"
"To apply `«{h2}»` to `A`, we just write `«{h2}»` followed by `A`, with a space between them.\n"
"Thus, your next step can be `have «{h2}»A : A ∈ F → «{x}» ∈ A := «{h2}» A`.  You can save yourself\n"
"a little typing by writing `have «{h2}»A := «{h2}» A`; Lean will figure out what statement is\n"
"proven by `«{h2}» A`."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "Since we also have `h1 : A ∈ F`, you can apply `«{h2A}»` to `h1` to prove that `«{x}» ∈ A`.\n"
"This means that `«{h2A}» h1` is a proof of the goal."
msgstr ""

#: Game.Levels.FamInter.L01intersub
msgid "The last two steps could have been combined into one step.  In general, if you have\n"
"`h1 : A ∈ F` and `h2 : ∀ t ∈ F, P t`, where `P t` is some statement about `t`, then `h2 A`\n"
"is a proof of `A ∈ F → P A`, and\n"
"applying that proof to `h1` we conclude that `h2 A h1` is a proof of `P A`.  For example,\n"
"if you have `h1 : A ∈ F` and `h2 : ∀ t ∈ F, x ∈ t`, then `h2 A h1` is a proof of `x ∈ A`."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "Intersection of larger family is smaller"
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "In this level we have two families of sets, `F` and `G`, with `F ⊆ G`.  That means that\n"
"`⋂₀ G` is the intersection of a family of sets that includes all the sets in `F`, plus\n"
"perhaps more sets.  You're going to prove that intersecting this larger collection of sets\n"
"leads to a smaller result; more precisely, you're going to prove that `⋂₀ G ⊆ ⋂₀ F`.\n"
"\n"
"Of course, by now you know how to start a proof that one set is a subset of another."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\n"
"Then $\\bigcap G \\subseteq \\bigcap F$."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\n"
"Then $\\bigcap G \\subseteq \\bigcap F$."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "As usual, if you're not sure how to proceed then writing\n"
"out definitions can help."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "Now your goal starts with `∀ t`.  To prove it, you'll need to introduce\n"
"a set `t` into the proof, using the tactic `intro t`.  Recall that the set `t` is\n"
"*arbitrary*--that is, `t` could stand for any set--so whatever we prove about `t` will\n"
"be true for *all* sets `t`."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "Now your goal is an if-then statement; that means `intro` is\n"
"appropriate again, to introduce `«{t}» ∈ F` as a new assumption."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "It looks like `«{h2}»` could get you to the goal, if only\n"
"you knew that `«{t}» ∈ G`.  Can you prove that?"
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "You can now combine `«{h2}»` and `«{h4}»` to reach the goal in one step."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "`«{h2}» «{t}» «{h4}»` is now a proof of the goal."
msgstr ""

#: Game.Levels.FamInter.L02intersubinter
msgid "You probably used `intro` several times in this proof.  Recall that two `intro` steps in a row\n"
"can be combined into one step.  Click on `intro` in the list of tactics on the right for\n"
"further details."
msgstr ""

#: Game.Levels.FamInter.L04interunion
msgid "Intersection of a union of families"
msgstr ""

#: Game.Levels.FamInter.L04interunion
msgid "If `F` and `G` are families of sets, what is `⋂₀ (F ∪ G)`?  In this level, you'll find out!"
msgstr ""

#: Game.Levels.FamInter.L04interunion
msgid "Suppose $F$ and $G$ are families of sets.  Then\n"
"$\\bigcap (F \\cup G) = (\\bigcap F) \\cap (\\bigcap G)$."
msgstr ""

#: Game.Levels.FamInter.L04interunion
msgid "Here's an approach you might try:  If only you had `hFG : «{t}» ∈ F ∪ G`, then\n"
"`«{h1}» «{t}» hFG` would prove the goal.  So if you use the tactic `apply «{h1}» «{t}»`, Lean\n"
"will figure out that `«{h1}» «{t}»` could be applied to a proof of `«{t}» ∈ F ∪ G` to prove\n"
"the goal, and it will therefore set `«{t}» ∈ F ∪ G` as your goal."
msgstr ""

#: Game.Levels.FamInter.L05subinter
msgid "Subset of an intersection"
msgstr ""

#: Game.Levels.FamInter.L05subinter
msgid "If `A` is a set and `F` is a family of sets, under what circumstances is it the case\n"
"that `A ⊆ ⋂₀ F`?  In this level you'll discover the answer to that question."
msgstr ""

#: Game.Levels.FamInter.L05subinter
msgid "Suppose $A$ is a set and $F$ is a family of sets.  Then $A$ is a subset of $\\bigcap F$ if\n"
"and only if $A$ is a subset of every element of $F$."
msgstr ""

#: Game.Levels.FamInter.L05subinter
msgid "Suppose $A$ is a set and $F$ is a family of sets.  Then $A$ is a subset of $\\bigcap F$ if\n"
"and only if $A$ is a subset of every element of $F$."
msgstr ""

#: Game.Levels.FamInter.L05subinter
msgid "Notice that the parentheses in the next goal are necessary, to indicate that the universal\n"
"quantifier applies only to the subset statement.  Without the parentheses, Lean would interpret\n"
"the universal quantifier as applying to the entire rest of the statement."
msgstr ""

#: Game.Levels.FamInter
msgid "Family Intersection World"
msgstr ""

#: Game.Levels.FamInter
msgid "So far the elements of all of our sets have been objects in the universe `U`.  But\n"
"sets can contain other kinds of objects!  In the next two worlds, we will work with sets whose\n"
"elements are *sets of objects from `U`*.  We will call these *families of sets* from `U`.  To\n"
"indicate that `F` is a family of sets from `U`, we write `F : Set (Set U)`.\n"
"\n"
"For example, suppose `U` contains the people in a certain club, and we want to form a committee\n"
"consisting of five members of the club.  The set of all possible committees is a family\n"
"of sets from `U`.  Each element of this family is a set containing five club members.\n"
"\n"
"Families of sets are sets, and everything you've learned about sets applies to families of sets.\n"
"For example, if you have `F G : Set (Set U)` and `S : Set U`, then `mem_inter_iff S F G` is a proof\n"
"of the statement `S ∈ F ∩ G ↔ S ∈ F ∧ S ∈ G`.  Similarly, `mem_union S F G` is a proof of\n"
"`S ∈ F ∪ G ↔ S ∈ F ∨ S ∈ G`, and `mem_compl_iff F S` is a proof of `S ∈ Fᶜ ↔ S ∉ F`.\n"
"\n"
"In this world we extend the idea of intersections to families of sets.  If `F` is a family of\n"
"sets from `U`, then the *intersection* of the family `F` is the set of all objects from `U`\n"
"that belong to every element of `F`."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "Proving existential statements"
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "To work with unions of families, we'll need to know how to work with existential statements.\n"
"If `P x` is a statement about an unspecified object `x`, then `∃ x, P x` means \"there is\n"
"at least one `x` such that `P x` is true\".  The symbol `∃` is called the\n"
"*existential quantifier*, and you can enter it in Lean by typing `\\exists`.\n"
"\n"
"The easiest way to prove the statement `∃ x, P x` is to specify a value of `x`, and give a\n"
"proof of `P x` for that value of `x`.  The theorem that allows you to do that is called\n"
"`Exists.intro`.  If you have `h : P a`, for some object `a`, then `Exists.intro a h` is a\n"
"proof of the statement `∃ x, P x`.  (The object `a` is sometimes called a *witness* for\n"
"the existential statement.)  In this level, you'll try out this theorem."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "If `P x` represents a statement about `x`, then `∃ x, P x` means \"there is at least one\n"
"`x` such that `P x` is true\".  To enter the symbol `∃`, type `\\exists`.\n"
"\n"
"### If your goal is `∃ x, P x`\n"
"\n"
"If you have `h : P a`, for some object `a`, then `Exists.intro a h` is a proof of `∃ x, P x`,\n"
"so `exact Exists.intro a h` will close the goal.\n"
"If you think `P a` is true, but you don't yet have a proof of it, then `apply Exists.intro a`\n"
"will set `P a` as your goal.  The tactic `use a` does the same thing, but it also tries to\n"
"prove `P a`; if it doesn't succeed, then it leaves `P a` as a goal for you to prove.\n"
"\n"
"### If you have an assumption `h : ∃ x, P x`\n"
"\n"
"The tactic `obtain ⟨w, hw⟩ := h` will\n"
"introduce a new object `w` and a new assumption `hw : P w` into the proof.  To enter the\n"
"angle brackets `⟨ ⟩`, type either `\\<` and `\\>` or `\\langle` and `\\rangle`."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "If `P x` represents a statement about `x` and you have `h : P a`, for some object `a`, then\n"
"`Exists.intro a h` is a proof of `∃ x, P x`."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "Suppose $A$ is a set.  Then there is some set $S$ such that $S \\subseteq A$."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "Your goal says that there is a set that is a subset of `A`.\n"
"The theorem `Subset.refl` suggests such a set."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "Recall that `Subset.refl A` is a proof of `A ⊆ A`.\n"
"So start your proof with `have h : A ⊆ A := Subset.refl A`."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "Although `∅` is a reasonable choice for a set that is a subset of `A`, it is difficult\n"
"to complete the proof with this choice using only methods developed so far in this game.\n"
"Go back and try a different choice."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "Now you can use `Exists.intro` to complete the proof."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "`Exists.intro A «{h}»` is a proof of the goal, so `exact Exists.intro A «{h}»`\n"
"will close the goal."
msgstr ""

#: Game.Levels.FamUnion.L01proveexists
msgid "By the way, another set that would have worked as a witness for the existential goal in this\n"
"theorem is the empty set, denoted `∅`.  However, to justify the use of that witness you would\n"
"have had to prove `∅ ⊆ A`.  Since we already have the theorem `Subset.refl`, it was easier to use\n"
"`A` as the witness.\n"
"\n"
"Now that you know how to prove existential statements, you're ready to start working with\n"
"unions of families."
msgstr ""

#: Game.Levels.FamUnion.L02subunion
msgid "Subset of family union"
msgstr ""

#: Game.Levels.FamUnion.L02subunion
msgid "In mathematical writing, the union of the family $F$ is usually denoted $\\bigcup F$.\n"
"In Lean, the union of a family `F` is denoted `⋃₀ F`.  (You can enter the symbol\n"
"`⋃₀` by typing `\\U0`.)\n"
"\n"
"Suppose we have `F : Set (Set U)` and `x : U`.  Then `x ∈ ⋃₀ F` means that there is at least\n"
"one set `t` such that `t ∈ F` and `x ∈ t`.  To write this statement in Lean, we write\n"
"`∃ t, t ∈ F ∧ x ∈ t`.  Lean abbreviates this statement as `∃ t ∈ F, x ∈ t`.\n"
"\n"
"As with other set theory operations, we have a theorem that expresses this definition.  Lean will\n"
"recognize `mem_sUnion` as a proof of any statement of the form `x ∈ ⋃₀ F ↔ ∃ t ∈ F, x ∈ t`.\n"
"\n"
"In this level, you'll try out these ideas."
msgstr ""

#: Game.Levels.FamUnion.L02subunion
msgid "`⋃₀ F` is the union of the family of sets `F`.  To enter the symbol `⋃₀`, type `\\U0`."
msgstr ""

#: Game.Levels.FamUnion.L02subunion
msgid "Lean will recognize `mem_sUnion` as a proof of any statement of the form\n"
"`x ∈ ⋃₀ F ↔ ∃ t ∈ F, x ∈ t`.  In Mathlib, the name of this theorem is `Set.mem_sUnion`."
msgstr ""

#: Game.Levels.FamUnion.L02subunion
msgid "If your goal is `∃ x, P x`, where `P x` represents some statement about `x`, and `a` is a\n"
"value that could be assigned to `x`, then the tactic `use a` will\n"
"set `P a` to be the goal.  It will then see if this new goal follows easily from your\n"
"assumptions, and if so it will close the goal."
msgstr ""

#: Game.Levels.FamUnion.L02subunion
msgid "Suppose $F$ is a family of sets and $A \\in F$.  Then $A \\subseteq \\bigcup F$."
msgstr ""

#: Game.Levels.FamUnion.L02subunion
msgid "Remember that the goal `∃ t ∈ F, «{x}» ∈ t` is an abbreviation for\n"
"`∃ t, t ∈ F ∧ «{x}» ∈ t`.  As we saw in the last level, we can prove this by coming up with\n"
"a witness--that is, a value for `t` that will make the statement `t ∈ F ∧ «{x}» ∈ t` come out\n"
"true.  Looking at\n"
"`h1` and `«{h2}»`, it looks like `t = A` would work.  That suggests a way to proceed:\n"
"`Exists.intro A hA` would prove the goal, if `hA` were a proof of `A ∈ F ∧ «{x}» ∈ A`.  In\n"
"other words, if `Exists.intro A` is applied to a proof of `A ∈ F ∧ «{x}» ∈ A`, then it will\n"
"prove the goal.  So if you use the tactic `apply Exists.intro A`, then Lean will\n"
"set `A ∈ F ∧ «{x}» ∈ A` as your new goal."
msgstr ""

#: Game.Levels.FamUnion.L02subunion
msgid "There is another tactic you could have used to complete this proof.  Instead of\n"
"`apply Exists.intro A`, you could write `use A`.  The `use` tactic is actually a powerful\n"
"tactic.  Not only does it fill in `A` for `t` in the existential goal, it then tries to\n"
"complete the proof on its own--and in this case, it would have succeeded!"
msgstr ""

#: Game.Levels.FamUnion.L03unionsubunion
msgid "Union of larger family is larger"
msgstr ""

#: Game.Levels.FamUnion.L03unionsubunion
msgid "In this level we have two families of sets, `F` and `G`, with `F ⊆ G`.  In Family Intersection\n"
"World, you proved that in this situation, `⋂₀ G ⊆ ⋂₀ F`.  In this level, you'll prove that\n"
"with family unions, it works the other way: `⋃₀ F ⊆ ⋃₀ G`.\n"
"\n"
"We'll need a new tactic for this proof.  An assumption of the form `h : ∃ x, P x` tells you that\n"
"an object with a certain property exists.  If you have such an assumption, then it is usually\n"
"helpful to introduce a name for such an object.  You can do this with the `obtain` tactic.  If\n"
"you write `obtain ⟨w, hw⟩ := h`, then Lean will introduce a new object `w` and a new assumption\n"
"`hw : P w`.  Thus, the object `w` is a witness for the existential assumption `h`.  Note that\n"
"in the `obtain` tactic, `w` and `hw` must be enclosed in angle brackets: `⟨ ⟩`.  You can\n"
"enter these by typing either `\\<` and `\\>` or `\\langle` and `\\rangle`."
msgstr ""

#: Game.Levels.FamUnion.L03unionsubunion
msgid "If you have an assumption `y ∈ f '' A `, `obtain ⟨x, hxA, rfl⟩ := h`\n"
"will introduce a new object `x`, a proof `hxA` that `x ∈ A`, and will rewrite `y` into `f x`.\n"
"\n"
"If you have an assumption `h : ∃ x, P x`, then the tactic `obtain ⟨w, hw⟩ := h` will\n"
"introduce a new object `w` and a new assumption `hw : P w` into the proof.\n"
"\n"
"To enter the angle brackets `⟨ ⟩`, type either `\\<` and `\\>` or `\\langle` and `\\rangle`."
msgstr ""

#: Game.Levels.FamUnion.L03unionsubunion
msgid "Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\n"
"Then $\\bigcup F \\subseteq \\bigcup G$."
msgstr ""

#: Game.Levels.FamUnion.L03unionsubunion
msgid "Suppose $F$ and $G$ are families of sets and $F \\subseteq G$.\n"
"Then $\\bigcup F \\subseteq \\bigcup G$."
msgstr ""

#: Game.Levels.FamUnion.L03unionsubunion
msgid "The assumption `«{h2}»` is now an existential statement.  Thus, `obtain ⟨s, hs⟩ := «{h2}»`\n"
"will introduce a new object `s` and a new assumption `hs : s ∈ F ∧ «{x}» ∈ s` into the proof.\n"
"Once the witness `s` has been introduced, the assumption `«{h2}»` becomes redundant, so it is\n"
"deleted."
msgstr ""

#: Game.Levels.FamUnion.L03unionsubunion
msgid "Do you see why `«{s}»` is the value to use as a witness for `t` in the goal?\n"
"Your next step can be either `apply Exists.intro «{s}»` or `use «{s}»`."
msgstr ""

#: Game.Levels.FamUnion.L05unionunion
msgid "Union of a union"
msgstr ""

#: Game.Levels.FamUnion.L05unionunion
msgid "In this level, `F` and `G` are families of sets, and you'll work out how `⋃₀ (F ∪ G)` is related\n"
"to `⋃₀ F` and `⋃₀ G`."
msgstr ""

#: Game.Levels.FamUnion.L05unionunion
msgid "Suppose $F$ and $G$ are families of sets.  Then $\\bigcup (F \\cup G) =\n"
"(\\bigcup F) \\cup (\\bigcup G)$."
msgstr ""

#: Game.Levels.FamUnion.L06unionsub
msgid "Union subset of a set"
msgstr ""

#: Game.Levels.FamUnion.L06unionsub
msgid "Suppose `A` is a set and `F` is a family of sets.  In this level you'll determine the conditions\n"
"under which `⋃₀ F` is a subset of `A`."
msgstr ""

#: Game.Levels.FamUnion.L06unionsub
msgid "Suppose $A$ is a set and $F$ is a family of sets.  Then $\\bigcup F$ is a subset of $A$\n"
"if and only if every element of $F$ is a subset of $A$."
msgstr ""

#: Game.Levels.FamUnion.L06unionsub
msgid "Suppose $A$ is a set and $F$ is a family of sets.  Then $\\bigcup F$ is a subset of $A$\n"
"if and only if every element of $F$ is a subset of $A$."
msgstr ""

#: Game.Levels.FamUnion.L06unionsub
msgid "Notice that `«{h1}»` could be applied to a proof of `«{x}» ∈ ⋃₀ F` to\n"
"prove the goal.  That means that `apply «{h1}»` will set `«{x}» ∈ ⋃₀ F` as the goal."
msgstr ""

#: Game.Levels.FamUnion
msgid "Family Union World"
msgstr ""

#: Game.Levels.FamUnion
msgid "If `F` is a family of sets from `U`, then the *union* of `F` is the set of all objects from\n"
"`U` that belong to at least one element of `F`.  We'll investigate unions of families in this\n"
"world."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Intro to functions"
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Let's warm up with the following simple exercise."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Show that if $x = y$, then $f(x) = f(y)$."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "You can use the `rewrite [h]` to replace `x` with `y`."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Now you can use `rfl` to finish the proof. Recall that `rfl` means that the left-hand side and right-hand side of the equation are definitionally equal."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Level 1"
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Images of functions"
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "If $f \\colon X \\to Y$ and $A \\in X$, then the image of $A$ under $f$ is the set\n"
"$f(A) = \\{ f(x) \\mid x \\in A \\}$. In Lean, this is denoted `f '' A` or `image f A`.\n"
"\n"
"A hypothesis `y ∈ f '' A ` decomposes as a triple `⟨x, hxA, rfl⟩`, where `x` is an element of `A`, `hxA` is the proof that `x ∈ A`, and `rfl` is the proof that `f x = y`. This is a common pattern when working with images in Lean.\n"
"In this level, we will use the `obtain` tactic to decompose such hypotheses.\n"
"Whenever you have a hypothesis of the form `h : y ∈ f '' A`, you can write `obtain ⟨x, hxA, rfl⟩ := h` to decompose it into its components.\n"
"To write the symbols `⟨` and `⟩`, you can write \\langle and \\rangle, respectively.\n"
"\n"
"In this level, we prove the following property of images: If $A ⊆ B$, then $f(A) ⊆ f(B)$."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "If A ⊆ B, then $f(A) ⊆ f(B)$."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "If A ⊆ B, then $f(A) ⊆ f(B)$."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Let's star by choosing an element `y` in the left-hand side, using `intro`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "As usual when proving an implication, we can begin with `intro H`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Use `obtain` to decompose the hypothesis `«{y}» ∈ f '' A` into a triple ⟨x, hxA, rfl⟩."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "You can use the keyword `have` to create the hypothesis `«{x}» ∈ B`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "You can now complete the proof using `exact ⟨ «{x}», «{hxB}», rfl ⟩`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Well done!\n"
"If you don't want to use `obtain`, you can also apply the theorem `Set.mem_image`.\n"
"The command `rw [Set.mem_image] at h` will rewrite a hypothesis `h : y ∈ f '' A` into `∃ x ∈ A, f x = y`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "If you have an assumption `y ∈ f '' A `, `obtain ⟨x, hxA, rfl⟩ := h`\n"
"will introduce a new object `x`, a proof `hxA` that `x ∈ A`, and will rewrite `y` into `f x`.\n"
"\n"
"If you have an assumption `h : ∃ x, P x`, then the tactic `obtain ⟨w, hw⟩ := h` will\n"
"introduce a new object `w` and a new assumption `hw : P w` into the proof.\n"
"\n"
"To enter the angle brackets `⟨ ⟩`, type either `\\<` and `\\>` or `\\langle` and `\\rangle`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "$y$ is in $f(A)$ if and only if there exists a $x \\in A$ such that $f(x) = y$."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Image of a set under a function. Can be written as `f '' A` or `Set.image f A`."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Image of union"
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "In this level, we will prove that the image of the union of two sets is equal to the union of their images."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "The theorem $f(A ∪ B) = f(A) ∪ f(B)$."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Show that $f(A ∪ B) = f(A) ∪ f(B)$."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Recall that you can use the `ext` tactic to prove that two sets are equal."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "You can apply Iff.intro to split the goal into two subgoals."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "As in the previous level, you can use `intro` followed by `obtain` here."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "You can use `rcases «{hx}»` to split the proof into two cases."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "The tactics `left` and `right` can be useful here."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Recall the syntax `exact ⟨«{x}», «{h}», rfl⟩` to finish the proof in each case."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "The second subgoal can be solved similarly."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "The theorems `Or.inl` and `Or.inr` can be useful here."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Image of intersection"
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid ""
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "The theorem $f(A ∩ B) ⊆ f(A) ∩ f(B)$."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Show that $f(A ∩ B) ⊆ f(A) ∩ f(B)$."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "This level can be solved in a similar way to the previous one. You can start by introducing an element with `intro y`."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Now, `intro h` will introduce a hypothesis `h : «{y}» ∈ «{f}» '' («{A}» ∩ «{B}»)` and change you goal to `«{y}» ∈ «{f}»'' «{A}» ∩ «{y}» ∈ «{f}»'' «{B}»`."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Recall that for two sets `A` and `B`, `a ∈ A ∩ B` is equivalent to `a ∈ A ∧ a ∈ B`. Some useful techniques: `apply And.intro` will split the goal into two subgoals. For a hypothesis `h : a ∈ S ∩ T`, `h.left` gives you a proof of `a ∈ S` and `h.right` gives you a proof of `a ∈ T`."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Preimages of functions"
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "In this level, we introduce preimages of functions.\n"
"The preimage of a set $A$ under a function $f$ is the set of all elements in the domain of $f$ that map to elements in $A$.\n"
"In Lean, this is denoted `f ⁻¹' A`, which can be typed as `\\-1` followed by `'`, or written as `Set.preimage f A`.\n"
"\n"
"The theorem `Set.mem_preimage` states that an element $x$ is in the preimage of $A$ under $f$ if and only if $f(x)$ is in $A$.\n"
"You can use the command `rewrite [Set.mem_preimage]` to rewrite a hypothesis of the form `x ∈ f ⁻¹' A` into `f x ∈ A`."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "If A ⊆ B, then $f^{-1}(A) ⊆ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "If A ⊆ B, then $f^{-1}(A) ⊆ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Let's start by choosing an element `x` in the left-hand side, using `intro`."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "As usual when proving an implication, we can begin with `intro H`."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Try `rewrite [Set.mem_preimage] at «{H}»`, followed by `rewrite [Set.mem_preimage]`."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Recall that `«{h}» : A ⊆ B` is a proof that `a ∈ A` implies `a ∈ B`. You can use this to finish the level."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "$x$ is in $f^{-1}(A)$ if and only if $f(x) \\in A$."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Preimage of a set under a function. To write the preimage, use `f ⁻¹' A`, which can be typed as `\\-1` followed by `'`, or write  `Set.preimage f A`."
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "Preimage of union"
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "In this level, there's no hints. Try to solve it using what you've learned so far!"
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "The theorem $f^{-1}(A ∪ B) = f^{-1}(A) ∪ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "Show that $f^{-1}(A ∪ B) = f^{-1}(A) ∪ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "Preimage of intersection"
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "In this level, there's no hints. Try to solve it using what you've learned so far!"
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "The theorem $f^{-1}(A ∩ B) = f^{-1}(A) ∩ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "Show that $f^{-1}(A ∩ B) = f^{-1}(A) ∩ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "Preimage of complement"
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "In this level, we prove that $f^{-1}(A^c) = f^{-1}(A)^c$,\n"
"where $A^c$ is the complement of $A$ in the universe of discourse.\n"
"In Lean, this is denoted `Aᶜ` or `Set.compl A`, and can be written `\\^c`.\n"
"Recall that `x ∈ Aᶜ ↔ x ∉ A`."
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "The theorem $f^{-1}(A^c) = f^{-1}(A)^c$"
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "Show that $f^{-1}(A^c) = f^{-1}(A)^c$."
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "In this level, it can be useful to use `rw [mem_compl_iff]` or `rw [mem_compl_iff] at h` to rewrite at statement `a ∈ Sᶜ` to `a ∉ S`."
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "Another useful technique is to use `by_contra` to do a proof by contradiction."
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "Image of preimage"
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "In this level, there's no hints. Try to solve it using what you've learned so far!"
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "The theorem $f(f^{-1}(A)) \\subseteq A $."
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "Show that $f(f^{-1}(A)) \\subseteq A $."
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "Preimage of image"
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "In this level, there's no hints. Try to solve it using what you've learned so far!"
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "The theorem $A \\subseteq f^{-1}(f(A))$."
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "Show that $A \\subseteq f^{-1}(f(A))$."
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "Composition of functions"
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "In this level, we introduce the composition of functions.\n"
"The composition of two functions $f : X \\to Y$ and $g : Y \\to Z$ is a function $g \\circ f : X \\to Z$ defined by $(g \\circ f)(x) = g(f(x))$ for all $x \\in X$.\n"
"\n"
"In Lean, the composition of functions is denoted by `g ∘ f` or `Function.comp g f`.\n"
"To write the `∘` symbol, you can type `\\circ` in the editor.\n"
"\n"
"In this level, we also introduce a new tactic, `use`, which is useful when working with images of functions.\n"
"If your goal is `y ∈ f '' A`, `use x` will change the goal to `x ∈ A` and `f x = y`."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "The theorem $(g \\circ f)(A) = g(f(A))$."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "Show that $(g \\circ f)(A) = g(f(A))$."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "The theorem `Function.comp_apply` can be used to rewrite `(g ∘ f) x` as `g (f x)`."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "Try 'rewrite [Function.comp_apply]'."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "Now, you can use `use` to finish the subgoal. Try `use «{f}» «{x}»`."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "Now, you can use `use` to finish the subgoal. Try `use «{x}»`."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "If your goal is `y ∈ f '' A`, `use x` will change the goal to `x ∈ A` and `f x = y`."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "The composition of two functions $f : X \\to Y$ and $g : Y \\to Z$ is a function $g \\\\circ f : X \\\\to Z$ defined by $(g \\\\circ f)(x) = g(f(x))$ for all $x \\\\in X$.\n"
"\n"
"The theorem `Function.comp_apply` can be used to rewrite `(g ∘ f) x` as `g (f x)`."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "$(g \\circ f) (x) = g(f(x))$"
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "Preimage of composition"
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "The final level in this world!"
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "The theorem $(g \\circ f)^{-1}(A) = f^{-1}(g^{-1}(A))$."
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "Show that $(g \\circ f)^{-1}(A) = f^{-1}(g^{-1}(A))$."
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions
msgid "Functions"
msgstr ""

#: Game.Levels.Functions
msgid "This module contains exercises related to functions, images, and preimages."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Introduction to topological spaces"
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "In this level, we introduce the `TopologicalSpace` typeclass.\n"
"The statement `TopologicalSpace X` means that `X` is a topological space.\n"
"\n"
"The `TopologicalSpace` typeclass is defined as follows:\n"
"\n"
"```\n"
"class TopologicalSpace (X : Type u) where\n"
"  protected IsOpen : Set X → Prop\n"
"  protected isOpen_univ : IsOpen univ\n"
"  protected isOpen_inter : ∀ s t, IsOpen s → IsOpen t → IsOpen (s ∩ t)\n"
"  protected isOpen_sUnion : ∀ s, (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)\n"
"```\n"
"\n"
"It's okay if you don't understand all of this.\n"
"We will only focus on some of it now, and get to the rest in later worlds.\n"
"\n"
"The `IsOpen` predicate is used to determine whether a set is open in the topological space.\n"
"You can treat it as a function: given `h : TopologicalSpace X` and `U : Set X`,\n"
"the expression `h.IsOpen U` returns `true` if `U` is open and `false` otherwise.\n"
"\n"
"The other three lines are the axioms of a topological space.\n"
"You can treat them as theorems: If `U` and `V` are open set in `X`,\n"
"and you have hypotheses `hU : h.IsOpen U` and `hV : h.IsOpen V`,\n"
"then `h.isOpen_inter U V hU hV` is a proof of `h.IsOpen (U ∩ V)`.\n"
"\n"
"Note also that it Lean, it often suffices to write `IsOpen U` instead of `h.IsOpen U`.\n"
"This is because Lean can often infer the topological space from the type of `U`.\n"
"\n"
"Observe that It's not explcitly stated in the axioms that the empty set is open,\n"
"because this follows from the fact that a union of open sets is open, applied to the empty union.\n"
"We will prove this in a later level!\n"
"\n"
"We start with a warm-up exercise."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Show that if $U, V$ and $W$ are open sets in $X$, then $U ∩ V ∩ W$ is open."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Start by introducing three hypotheses, with `intro hU hV hW`."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Now, you can use `«{h}».isOpen_inter` to prove that the intersection of two open sets is open. For example, try `have hUV := h.isOpen_inter «{U}» «{V}» «{hU}» «{hV}»`."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Finish by using `«{h}».isOpen_inter` again. You might need to rewrite using `inter_assoc` and/or `inter_comm`."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Level completed!"
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "The `TopologicalSpace` typeclass is defined as follows:\n"
"\n"
"```\n"
"class TopologicalSpace (X : Type u) where\n"
"  protected IsOpen : Set X → Prop\n"
"  protected isOpen_univ : IsOpen univ\n"
"  protected isOpen_inter : ∀ s t, IsOpen s → IsOpen t → IsOpen (s ∩ t)\n"
"  protected isOpen_sUnion : ∀ s, (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)\n"
"```\n"
"\n"
"The `IsOpen` predicate is used to determine whether a set is open in the topological space.\n"
"You can treat it as a function: given `h : TopologicalSpace X` and `U : Set X`,\n"
"the expression `h.IsOpen U` returns `true` if `U` is open and `false` otherwise.\n"
"\n"
"The other three lines are the axioms of a topological space.\n"
"You can treat them as theorems: If `U` and `V` are open set in `X`,\n"
"and you have hypotheses `hU : h.IsOpen U` and `hV : h.IsOpen V`,\n"
"then `h.isOpen_inter U V hU hV` is a proof of `h.IsOpen (U ∩ V)`.\n"
"\n"
"Note also that it Lean, it often suffices to write `IsOpen U` instead of `h.IsOpen U`.\n"
"This is because Lean can often infer the topological space from the type of `U`."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "Closed sets"
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "In this level we introduce closed sets.\n"
"In Lean, the predicate `IsClosed` asserts that a set is closed.\n"
"If U is a set in a topological space X, then `IsClosed U` is defined as `IsOpen Uᶜ`,\n"
"where `Uᶜ` is the complement of U.\n"
"\n"
"You can use the theorem `isOpen_compl_iff` to rewrite `IsClosed U` as `IsOpen Uᶜ`, and vice versa."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "Show that if $U$ and $V$ are closed sets in $X$, then $U ∪ V$ is closed."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "In this level, you can use the theorem `compl_union`, that you proved in Combination World, to rewrite ` (U ∪ V)ᶜ` as `Uᶜ ∩ Vᶜ`."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "You can use `rw [← isOpen_compl_iff]` to rewrite `IsClosed U` as `IsOpen Uᶜ`."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "Here it would be a good idea to use the theorem `compl_union`."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "$U^c$ is open if and only if $U$ is closed."
msgstr ""

#: Game.Levels.Spaces
msgid "Topological spaces"
msgstr ""

#: Game.Levels.Spaces
msgid "This module introduces the basics of topological spaces."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Introduction to continuous functions"
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "In this world, we introduce continuous functions.\n"
"In Lean, the predicate `Continuous` asserts that a function is continuous.\n"
"Given a proposition `h : Continuous f`, you can use `h.isOpen_preimage` to prove that the preimage of an open set is open.\n"
"\n"
"Let's warm up by proving that the continuous preimage of a closed set is closed.\n"
"\n"
"In this level, you can use the theorem `PreimageComplement`, which you proved in the functions world,\n"
"to rewrite `f⁻¹' (Uᶜ)` as `(f⁻¹' U)ᶜ`."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "If $f \\colon X \\to Y$ and $U \\subset Y$ is closed, then $f^{-1}(U)$ is closed."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "As always, start with `intro h`."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Recall the theorem `isOpen_compl_iff`. You can rewrite the statements in terms of open sets by writing `rw [← isOpen_compl_iff]` and `rw [← isOpen_compl_iff] at «{h}»`."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Remember in the functions world, we proved that the preimage of a complement is the complement of the preimage. You can use the theorem in this level, by writing `rw [← PreimageComplement]`."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Now you can use `«{hf}».isOpen_preimage` to finish the proof."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Level completed!"
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "The typeclass `Continuous` is defined as follows:\n"
"\n"
"```\n"
"class Continuous {X Y : Type} [TopologicalSpace X] [TopologicalSpace Y] (f : X → Y) where\n"
"  isOpen_preimage : ∀ {U : Set Y}, IsOpen U → IsOpen (f ⁻¹' U)\n"
"```\n"
"\n"
"If you have hypotheses `hf : Continuous f` and `hU : isOpen U`, then `hf.isOpen_preimage U hU` is a proof of `isOpen (f ⁻¹' U)`."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "Composition of continuous functions"
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "In this level, we prove that the composition of continuous functions is continuous.\n"
"\n"
"We introduce the theorem `continuous_def`, which states that a function is continuous if and only if the preimage of every open set is open."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "The composition of continuous functions is continuous."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "In this level, you can use the theorem `continuous_def`, which states that a function is continuous if and only if the preimage of every open set is open. Try using `rw [continuous_def]`."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "Now, try `intro U hU` to introduce an open set."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "In this level, you can use the theorem `PreimageComposition`, which you proved in the functions world."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "Again, you can use `«{hf}».isOpen_preimage` and `«{hg}».isOpen_preimage` to finish the proof."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "Level completed!"
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "A function is continuous if and only if the preimage of every open set is open."
msgstr ""

#: Game.Levels.Continuous
msgid "Continuous functions"
msgstr ""

#: Game.Levels.Continuous
msgid "This module introduces the basics of continuous functions."
msgstr ""

#: Game.Levels.Empty.L01_empty_set
msgid "The empty set"
msgstr ""

#: Game.Levels.Empty.L01_empty_set
msgid "In this level, we introduce the empty set, denoted `∅`.\n"
"We show that for any set $X$, the empty set is a subset of $X$.\n"
"\n"
"The only thing you need to know about the empty set is that it has no elements.\n"
"This is stated in the theorem `Set.not_mem_empty`.\n"
"For any `x`, `Set.not_mem_empty x` is a proof that `x ∉ ∅`."
msgstr ""

#: Game.Levels.Empty.L01_empty_set
msgid "For any set $U$, we have that $∅ ⊆ U$. For any set `U`, `EmptySubset U` is a proof that `∅ ⊆ U`."
msgstr ""

#: Game.Levels.Empty.L01_empty_set
msgid "For any set $U$, we have that $∅ ⊆ U$."
msgstr ""

#: Game.Levels.Empty.L01_empty_set
msgid "Start as you normally do when proving a subset relation, by introducing an arbitrary element `x` of the left-hand side and a hypothesis `h` that `x` is in the left-hand side."
msgstr ""

#: Game.Levels.Empty.L01_empty_set
msgid "Recall that `Set.not_mem_empty «{x}»` is a proof that `«{x}» ∉ ∅`."
msgstr ""

#: Game.Levels.Empty.L01_empty_set
msgid "The tactic `by_contra` can be used here."
msgstr ""

#: Game.Levels.Empty.L01_empty_set
msgid "No element is a member of the emptyset. For any `x`, `Set.not_mem_empty x` is a proof that `x ∉ ∅`."
msgstr ""

#: Game.Levels.Empty.L01_empty_set
msgid "The empty set, denoted `∅`, is the unique set with no elements.\n"
"To input the symbol `∅`, you can type `\\empty`.\n"
"\n"
"The theorem `Set.not_mem_empty` states that for any `x`, `Set.not_mem_empty x` is a proof that `x ∉ ∅`."
msgstr ""

#: Game.Levels.Empty.L02_empty_union
msgid "The empty union"
msgstr ""

#: Game.Levels.Empty.L02_empty_union
msgid "We show that the union over the empty family of sets is the empty set.\n"
"\n"
"Now that you have completed the Family Union world, you know have to deal with unions of families of sets."
msgstr ""

#: Game.Levels.Empty.L02_empty_union
msgid "The union over the empty family of sets is the empty set. I.e., $⋃ ∅ = ∅$."
msgstr ""

#: Game.Levels.Empty.L02_empty_union
msgid "The union over the empty family of sets is the empty set."
msgstr ""

#: Game.Levels.Empty.L02_empty_union
msgid "To begin with, you can either use `ext x` or `Subset.antisymm`. If you use `Subset.antisymm`, you can use the theorem `EmptySubset` from the previous subset to prove one of the inclusions."
msgstr ""

#: Game.Levels.Empty.L02_empty_union
msgid "Recall that the theorem `mem_sUnion` unfolds the definition of membership in a union over a family of sets."
msgstr ""

#: Game.Levels.Empty.L03_empty_open
msgid "The empty set is open"
msgstr ""

#: Game.Levels.Empty.L03_empty_open
msgid "In this level, show that the empty set is open in any topological space.\n"
"\n"
"In this level, you will have to use the `isOpen_sUnion` property of topological spaces.\n"
"The `isOpen_sUnion` property states that the union over any collection of open sets is open.\n"
"Explicitly, `TopologicalSpace.isOpen_sUnion` is defined as\n"
"```\n"
"∀ s, (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)\n"
"```\n"
"You can look up the definition of `TopologicalSpace` in the right column if you want to read more."
msgstr ""

#: Game.Levels.Empty.L03_empty_open
msgid "Let $X$ be a topological space. Then $\\emptyset \\subseteq X$ is open."
msgstr ""

#: Game.Levels.Empty.L03_empty_open
msgid "Try using `h.isOpen_sUnion` on the empty collection."
msgstr ""

#: Game.Levels.Empty.L03_empty_open
msgid "You can use the theorem `sUnionEmpty` from the previous level."
msgstr ""

#: Game.Levels.Empty.L04_nonempty
msgid "Nonempty sets"
msgstr ""

#: Game.Levels.Empty.L04_nonempty
msgid "In this level, we introduce nonempty sets.\n"
"\n"
"A set is nonempty if it contains at least one element.\n"
"Specifically, for a set `S`, `S.Nonempty` is defined as `∃ x, x ∈ S`.\n"
"Whenever you have a hypothesis `h : S.Nonempty` (or `h : Set.Nonempty S`),\n"
"you can use `obtain ⟨x, h1⟩ := h` to get an element `x` and a proof `h1` that `x ∈ S`.\n"
"\n"
"You can also use the theorem `Set.nonempty_def` to rewrite `S.Nonempty` into `∃ x, x ∈ S` and vice versa."
msgstr ""

#: Game.Levels.Empty.L04_nonempty
msgid "A set is nonempty if and only if it is not equal to the empty set."
msgstr ""

#: Game.Levels.Empty.L04_nonempty
msgid "Show that a set is nonempty if and only if it is not equal to the empty set."
msgstr ""

#: Game.Levels.Empty.L04_nonempty
msgid "Try using `push_neg`."
msgstr ""

#: Game.Levels.Empty.L04_nonempty
msgid "For a set `S`, `S.Nonempty` is defined as `∃ x, x ∈ S`.\n"
"Whenever you have a hypothesis `h : S.Nonempty` (or `h : Set.Nonempty S`),\n"
"you can use `obtain ⟨x, h1⟩ := h` to get an element `x` and a proof `h1` that `x ∈ S`."
msgstr ""

#: Game.Levels.Empty.L04_nonempty
msgid "A set $S$ is nonempty if and only if there exists an element $x$ such that $x ∈ S$."
msgstr ""

#: Game.Levels.Empty.L05_empty_preimage
msgid "Preimage of the empty set"
msgstr ""

#: Game.Levels.Empty.L05_empty_preimage
msgid "In this level, we show that the preimage of the empty set under any function is the empty set."
msgstr ""

#: Game.Levels.Empty.L05_empty_preimage
msgid "If $f : X → Y$ is any function, then $f^{-1}(∅) = ∅$."
msgstr ""

#: Game.Levels.Empty.L05_empty_preimage
msgid "If $f : X → Y$ is any function, then $f^{-1}(∅) = ∅$."
msgstr ""

#: Game.Levels.Empty.L05_empty_preimage
msgid "At some point in this proof, you might end up with a hypothesis `h : f x ∈ ∅`. In this case, `Set.not_mem_empty (f x) h` is a proof of `false`. Thus, `by_contra` followed by `exact Set.not_mem_empty (f x) h` is one way to finish the proof. However, this also works if you don't write `by_contra` first. This is because Lean recognizes that `false` is sufficient to prove anything, so `exact false` is a proof of any statement. Do you see why `false` should imply any statement?"
msgstr ""

#: Game.Levels.Empty.L06_empty_image
msgid "Image of the empty set"
msgstr ""

#: Game.Levels.Empty.L06_empty_image
msgid "In this level, we show that the image of the empty set under any function is the empty set."
msgstr ""

#: Game.Levels.Empty.L06_empty_image
msgid "If $f : X → Y$ is any function, then $f(∅) = ∅$."
msgstr ""

#: Game.Levels.Empty.L06_empty_image
msgid "If $f : X → Y$ is any function, then $f(∅) = ∅$."
msgstr ""

#: Game.Levels.Empty.L07_nonempty_image
msgid "Image of a nonempty empty set"
msgstr ""

#: Game.Levels.Empty.L07_nonempty_image
msgid "In this level, we show that the image of a nonempty set under any function is nonempty."
msgstr ""

#: Game.Levels.Empty.L07_nonempty_image
msgid "If $f : X → Y$ is any function, and $U ⊆ X$ is nonempty, then $f(U)$ is nonempty."
msgstr ""

#: Game.Levels.Empty.L07_nonempty_image
msgid "If $f : X → Y$ is any function, and $U ⊆ X$ is nonempty, then $f(U)$ is nonempty."
msgstr ""

#: Game.Levels.Empty.L08_empty_inter
msgid "Intersection with the empty set"
msgstr ""

#: Game.Levels.Empty.L08_empty_inter
msgid "In this level, we show that the intersection of any set with the empty set is empty."
msgstr ""

#: Game.Levels.Empty.L08_empty_inter
msgid "For any set $U$, $∅ ∩ U = ∅$."
msgstr ""

#: Game.Levels.Empty.L08_empty_inter
msgid "For any set $U$, $∅ ∩ U = ∅$."
msgstr ""

#: Game.Levels.Empty
msgid "The empty set"
msgstr ""

#: Game.Levels.Empty
msgid "This module introduces the empty set."
msgstr ""

#: Game.Levels.Connected.L01_preconnected
msgid "Preconnected sets"
msgstr ""

#: Game.Levels.Connected.L01_preconnected
msgid "In this level, we introduce preconnected sets.\n"
"\n"
"The `IsPreconnected` property is defined as follows.\n"
"```\n"
"def IsPreconnected (s : Set α) : Prop :=\n"
"  ∀ u v : Set α, IsOpen u → IsOpen v → s ⊆ u ∪ v → (s ∩ u).Nonempty → (s ∩ v).Nonempty →\n"
"    (s ∩ (u ∩ v)).Nonempty\n"
"```\n"
"In words, a set `s` in a topological space `α` is _preconnected_ if,\n"
"for any two open sets `u` and `v` in `α`  such that\n"
"`s ⊆ u ∪ v`, `s ∩ u` is nonempty and `s ∩ v` is nonempty,\n"
"we have that `s ∩ (u ∩ v)` is nonempty.\n"
"\n"
"You can treat `IsPreconnected` as a theorem. Typing `rw [IsPreconnected]` will unfold the definition."
msgstr ""

#: Game.Levels.Connected.L01_preconnected
msgid "The empty set is preconnected."
msgstr ""

#: Game.Levels.Connected.L01_preconnected
msgid "You can begin unwrapping the `IsPreconnected` definition by introducing several variables and hypotheses, like so: `intro V W hV hW hVWunion hV1 hW1`."
msgstr ""

#: Game.Levels.Connected.L01_preconnected
msgid "Use the theorem `EmptyInter` to show that `«{V}» ∩ ∅ = ∅`."
msgstr ""

#: Game.Levels.Connected.L01_preconnected
msgid "Remember that we proved the theorem `NonemptyIffNotEmpty` the Empty world, which says that a set is `Nonempty` if and only it is not equal to the empty set. You can use that to create a contradiction here."
msgstr ""

#: Game.Levels.Connected.L01_preconnected
msgid "If you have `«{hV1}»: ¬ (∅ = ∅)`, then `«{hV1}» rfl` is a proof of `false`."
msgstr ""

#: Game.Levels.Connected.L01_preconnected
msgid "The `IsPreconnected` property is defined as follows.\n"
"```\n"
"def IsPreconnected (s : Set α) : Prop :=\n"
"  ∀ u v : Set α, IsOpen u → IsOpen v → s ⊆ u ∪ v → (s ∩ u).Nonempty → (s ∩ v).Nonempty →\n"
"    (s ∩ (u ∩ v)).Nonempty\n"
"```\n"
"In words, a set `s` in a topological space `α` is _preconnected_ if,\n"
"for any two open sets `u` and `v` in `α`  such that\n"
"`s ⊆ u ∪ v`, `s ∩ u` is nonempty and `s ∩ v` is nonempty,\n"
"we have that `s ∩ (u ∩ v)` is nonempty.\n"
"\n"
"You can treat `IsPreconnected` as a theorem. Typing `rw [IsPreconnected]` will unfold the definition."
msgstr ""

#: Game.Levels.Connected.L02_connected
msgid "Connected sets"
msgstr ""

#: Game.Levels.Connected.L02_connected
msgid "In this level, we introduce connected sets.\n"
"\n"
"The `Connected` property is simple. It's defined as follows.\n"
"```\n"
"def IsConnected (s : Set α) : Prop :=\n"
"  s.Nonempty ∧ IsPreconnected s\n"
"```\n"
"In words, a set `s` in a topological space `α` is _connected_ if it is nonempty and preconnected.\n"
"\n"
"As for `IsPreconnected`, you can treat `IsConnected` as a theorem. Typing `rw [IsConnected]` will unfold the definition.\n"
"\n"
"As a warm-up, we show that the empty set is not connected."
msgstr ""

#: Game.Levels.Connected.L02_connected
msgid "The empty set is not connected."
msgstr ""

#: Game.Levels.Connected.L02_connected
msgid "The `Connected` property is defined as follows.\n"
"```\n"
"def IsConnected (s : Set α) : Prop :=\n"
"  s.Nonempty ∧ IsPreconnected s\n"
"```\n"
"In words, a set `s` in a topological space `α` is _connected_ if it is nonempty and preconnected.\n"
"\n"
"You can treat `IsConnected` as a theorem. Typing `rw [IsConnected]` will unfold the definition."
msgstr ""

#: Game.Levels.Connected.L03_connected_image
msgid "Continuous image of a connected set"
msgstr ""

#: Game.Levels.Connected.L03_connected_image
msgid "This level is the hardest one in this Game so far.\n"
"But, by now, you should have all the necessary tools to complete it.\n"
"\n"
"Some general tips for this level:\n"
"* Many of the you have proved in previous worlds can be applied here to make the proof simpler.\n"
"* You can use the `have` tactic to prove a statement over multiple lines. Look up the documentation in the left column for more details.\n"
"* If you get stuck, try solving the problem with pen and paper first.\n"
"\n"
"Good luck!"
msgstr ""

#: Game.Levels.Connected.L03_connected_image
msgid "The continuous image of a connected set is connected"
msgstr ""

#: Game.Levels.Connected
msgid "Connected sets"
msgstr ""

#: Game.Levels.Connected
msgid "This module introduces the basics of connected sets in topology.\n"
"\n"
"In lean, a set `U` in a topological space `X` is _preconnected_ if,\n"
"for any two open sets `V` and `W` in `X`  such that\n"
"`U ⊆ V ∪ W`, `U ∩ V ≠ ∅` and `U ∩ W ≠ ∅`,\n"
"we have that `U ∩ (V ∩ W) ≠ ∅`.\n"
"\n"
"A set `U ⊆ X` is _connected_ if it is preconnected and nonempty."
msgstr ""

#: Game
msgid "The topology game"
msgstr ""

#: Game
msgid "Welcome to the topology game!\n"
"\n"
"In this game, you learn to work with topological spaces in Lean.\n"
"\n"
"Some of the worlds in this game are from the Set Theory Game, created by Daniel J. Velleman."
msgstr ""

#: Game
msgid "In this game, you learn to work with topological spaces in Lean.\n"
"\n"
"Some of the worlds in this game are from the Set Theory Game, created by Daniel J. Velleman."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
