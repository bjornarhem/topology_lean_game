msgid ""
msgstr "Project-Id-Version: Game v4.7.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: Sat Aug 23 12:49:10 2025\n"
"Last-Translator: \n"
"Language-Team: none\n"
"Language: en\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit"

#: GameServer.RpcHandlers
msgid "level completed! 🎉"
msgstr ""

#: GameServer.RpcHandlers
msgid "level completed with warnings… 🎭"
msgstr ""

#: GameServer.RpcHandlers
msgid "intermediate goal solved! 🎉"
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Intro to functions"
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Let's warm up with the following simple exercise."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Show that if $x = y$, then $f(x) = f(y)$."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "You can use the `subst` tactic to replace `y` with `x`. Typing either `subst h` or `subst y` will work."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Now you can use `rfl` to finish the proof. Recall that `rfl` means that the left-hand side and right-hand side of the equation are definitionally equal."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Level 1"
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid ""
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid ""
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid ""
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid ""
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Intersection of sets. To enter the symbol `∩`, type `\\cap` of `\\inter`."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Intersection of sets. To enter the symbol `∪` type `\\cup` or `\\union`."
msgstr ""

#: Game.Levels.Functions.L01_functions
msgid "Complement of a set. To enter the symbol `ᶜ`, type `\\^c` or `\\compl`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Images of functions"
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "If $f \\colon X \\to Y$ and $A \\in X$, then the image of $A$ under $f$ is the set\n"
"$f(A) = \\{ f(x) \\mid x \\in A \\}$. In Lean, this is denoted `f '' A` or `image f A`.\n"
"\n"
"A hypothesis `y ∈ f '' A ` decomposes as a triple `⟨x, hxA, rfl⟩`, where `x` is an element of `A`, `hxA` is the proof that `x ∈ A`, and `rfl` is the proof that `f x = y`. This is a common pattern when working with images in Lean.\n"
"In this level, we will use the `rcases` tactic to decompose such hypotheses.\n"
"Whenever you have a hypothesis of the form `h : y ∈ f '' A`, you can write `rcase h with ⟨x, hxA, rfl⟩` to decompose it into its components.\n"
"To write the symbols `⟨` and `⟩`, you can write \\langle and \\rangle, respectively.\n"
"\n"
"In this level, we prove the following property of images: If $A ⊆ B$, then $f(A) ⊆ f(B)$."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "If A ⊆ B, then $f(A) ⊆ f(B)$."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "If A ⊆ B, then $f(A) ⊆ f(B)$."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Let's star by choosing an element `y` in the left-hand side, using `intro`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "As usual when proving an implication, we can begin with `intro H`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Use `rcases` to decompose the hypothesis `«{y}» ∈ f '' A` into a triple ⟨x, hxA, rfl⟩."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "You can use the keyword `have` to create the hypothesis `«{x}» ∈ B`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "You can now complete the proof using `exact ⟨ «{x}», «{hxB}», rfl ⟩`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Well done!\n"
"If you don't want to use `rcases`, you can also apply the theorem `Set.mem_image`.\n"
"The command `rw [Set.mem_image] at h` will rewrite a hypothesis `h : y ∈ f '' A` into `∃ x ∈ A, f x = y`."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "$y$ is in $f(A)$ if and only if there exists a $x \\in A$ such that $f(x) = y$."
msgstr ""

#: Game.Levels.Functions.L02_image
msgid "Image of a set under a function. Can be written as `f '' A` or `Set.image f A`."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Image of union"
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "In this level, we will prove that the image of the union of two sets is equal to the union of their images."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "The theorem $f(A ∪ B) = f(A) ∪ f(B)$."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Show that $f(A ∪ B) = f(A) ∪ f(B)$."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Recall that you can use the `ext` tactic to prove that two sets are equal."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "You can apply Iff.intro to split the goal into two subgoals."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "As in the previous level, you can use `intro` followed by `rcases` here."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "You can use `cases «{hx}»` to split the proof into two cases."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "The tactics `left` and `right` can be useful here."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Recall the syntax `exact ⟨«{x}», «{h}», rfl⟩` to finish the proof in each case."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "The second subgoal can be solved similarly."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "The theorems `Or.inl` and `Or.inr` can be useful here."
msgstr ""

#: Game.Levels.Functions.L03_image_union
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Image of intersection"
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid ""
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Show that $f(A ∩ B) ⊆ f(A) ∩ f(B)$."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Show that $f(A ∩ B) ⊆ f(A) ∩ f(B)$."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "This level can be solved in a similar way to the previous one. You can start by introducing an element with `intro y`."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Now, `intro h` will introduce a hypothesis `h : «{y}» ∈ «{f}» '' («{A}» ∩ «{B}»)` and change you goal to `«{y}» ∈ «{f}»'' «{A}» ∩ «{y}» ∈ «{f}»'' «{B}»`."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Recall that for two sets `A` and `B`, `a ∈ A ∩ B` is equivalent to `a ∈ A ∧ a ∈ B`. Some useful techniques: `apply And.intro` will split the goal into two subgoals. For a hypothesis `h : a ∈ S ∩ T`, `h.left` gives you a proof of `a ∈ S` and `h.right` gives you a proof of `a ∈ T`."
msgstr ""

#: Game.Levels.Functions.L04_image_intersection
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Preimages of functions"
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "In this level, we introduce preimages of functions.\n"
"The preimage of a set $A$ under a function $f$ is the set of all elements in the domain of $f$ that map to elements in $A$.\n"
"In Lean, this is denoted `f ⁻¹' A`, which can be typed as `\\-1` followed by `'`, or written as `Set.preimage f A`.\n"
"\n"
"The theorem `Set.mem_preimage` states that an element $x$ is in the preimage of $A$ under $f$ if and only if $f(x)$ is in $A$.\n"
"You can use the command `rewrite [Set.mem_preimage]` to rewrite a hypothesis of the form `x ∈ f ⁻¹' A` into `f x ∈ A`."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "If A ⊆ B, then $f^{-1}(A) ⊆ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "If A ⊆ B, then $f^{-1}(A) ⊆ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Let's start by choosing an element `x` in the left-hand side, using `intro`."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "As usual when proving an implication, we can begin with `intro H`."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Try `rewrite [Set.mem_preimage] at «{H}»`, followed by `rewrite [Set.mem_preimage]`."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Recall that `«{h}» : A ⊆ B` is a proof that `a ∈ A` implies `a ∈ B`. You can use this to finish the level."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "$x$ is in $f^{-1}(A)$ if and only if $f(x) \\in A$."
msgstr ""

#: Game.Levels.Functions.L05_preimage
msgid "Preimage of a set under a function. To write the preimage, use `f ⁻¹' A`, which can be typed as `\\-1` followed by `'`, or write  `Set.preimage f A`."
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "Preimage of union"
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "In this level, there's no hints. Try to solve it using what you've learned so far!"
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "The theorem $f^{-1}(A ∪ B) = f^{-1}(A) ∪ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "Show that $f^{-1}(A ∪ B) = f^{-1}(A) ∪ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L06_preimage_union
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "Preimage of intersection"
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "In this level, there's no hints. Try to solve it using what you've learned so far!"
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "The theorem $f^{-1}(A ∩ B) = f^{-1}(A) ∩ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "Show that $f^{-1}(A ∩ B) = f^{-1}(A) ∩ f^{-1}(B)$."
msgstr ""

#: Game.Levels.Functions.L07_preimage_intersection
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "Preimage of complement"
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "In this level, we prove that $f^{-1}(A^c) = f^{-1}(A)^c$,\n"
"where $A^c$ is the complement of $A$ in the universe of discourse.\n"
"In Lean, this is denoted `Aᶜ` or `Set.compl A`, and can be written \\^c.\n"
"Recall that `x ∈ Aᶜ ↔ x ∉ A`."
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "The theorem $f^{-1}(A^c) = f^{-1}(A)^c$"
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "Show that $f^{-1}(A^c) = f^{-1}(A)^c$."
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "In this level, it can be useful to use `rw [Set.mem_compl_iff]` or `rw [Set.mem_compl_iff] at h` to rewrite at statement `a ∈ Sᶜ` to `a ∉ S`."
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "Another useful technique is to use `by_contra` to do a proof by contradiction."
msgstr ""

#: Game.Levels.Functions.L08_preimage_complement
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "Image of preimage"
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "In this level, there's no hints. Try to solve it using what you've learned so far!"
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "The theorem $f(f^{-1}(A)) \\subseteq A $."
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "Show that $f(f^{-1}(A)) \\subseteq A $."
msgstr ""

#: Game.Levels.Functions.L09_image_preimage
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "Preimage of image"
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "In this level, there's no hints. Try to solve it using what you've learned so far!"
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "The theorem $A \\subseteq f^{-1}(f(A))$."
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "Show that $A \\subseteq f^{-1}(f(A))$."
msgstr ""

#: Game.Levels.Functions.L10_preimage_image
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "Composition of functions"
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "In this level, we introduce the composition of functions.\n"
"The composition of two functions $f : X 	o Y$ and $g : Y 	o Z$ is a function $g \\circ f : X \\to Z$ defined by $(g \\circ f)(x) = g(f(x))$ for all $x \\in X$.\n"
"\n"
"In Lean, the composition of functions is denoted by `g ∘ f` or `Function.comp g f`.\n"
"To write the `∘` symbol, you can type `\\circ` in the editor."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "The theorem $(g \\circ f)(A) = g(f(A))$."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "Show that $(g \\circ f)(A) = g(f(A))$."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "The theorem `Function.comp_apply` can be used to rewrite `(g ∘ f) x` as `g (f x)`."
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "TODO: Docstring for g ∘ f"
msgstr ""

#: Game.Levels.Functions.L11_composition
msgid "$(g \\\\circ f) (x) = g(f(x))$"
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "Preimage of composition"
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "The final level in this world!"
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "The theorem $(g \\circ f)^{-1}(A) = f^{-1}(g^{-1}(A))$."
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "Show that $(g \\circ f)^{-1}(A) = f^{-1}(g^{-1}(A))$."
msgstr ""

#: Game.Levels.Functions.L12_composition_preimage
msgid "Level completed!"
msgstr ""

#: Game.Levels.Functions
msgid "Functions"
msgstr ""

#: Game.Levels.Functions
msgid "This module contains exercises related to functions, images, and preimages."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Introduction to topological spaces"
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "In this level, we introduce the `TopologicalSpace` typeclass.\n"
"The statement `TopologicalSpace X` means that `X` is a topological space.\n"
"\n"
"The `TopologicalSpace` typeclass is defined as follows:\n"
"\n"
"```\n"
"class TopologicalSpace (X : Type u) where\n"
"  protected IsOpen : Set X → Prop\n"
"  protected isOpen_univ : IsOpen univ\n"
"  protected isOpen_inter : ∀ s t, IsOpen s → IsOpen t → IsOpen (s ∩ t)\n"
"  protected isOpen_sUnion : ∀ s, (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)\n"
"```\n"
"\n"
"The `IsOpen` predicate is used to determine whether a set is open in the topological space.\n"
"You can treat it as a function: given `h : TopologicalSpace X` and `U : Set X`,\n"
"the expression `h.IsOpen U` returns `true` if `U` is open and `false` otherwise.\n"
"\n"
"The other three lines are the axioms of a topological space.\n"
"You can treat them as theorems: If `U` and `V` are open set in `X`,\n"
"and you have hypotheses `hU : h.IsOpen U` and `hV : h.IsOpen V`,\n"
"then `h.isOpen_inter U V hU hV` is a proof of `h.IsOpen (U ∩ V)`.\n"
"\n"
"Note also that it Lean, it often suffices to write `IsOpen U` instead of `h.IsOpen U`.\n"
"This is because Lean can often infer the topological space from the type of `U`.\n"
"\n"
"Note that It's not explcitly stated in the axioms that the empty set is open,\n"
"because this follows from the fact that a union of open sets is open, applied to the empty union.\n"
"We will prove this in a later level!\n"
"\n"
"We start with a warm-up exercise."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Show that if $U, V$ and $W$ are open sets in $X$, then $U ∩ V ∩ W$ is open."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Start by introducing three hypotheses, with `intro hU hV hW`."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Now, you can use `«{h}».isOpen_inter` to prove that the intersection of two open sets is open. For example, try `have hUV := h.isOpen_inter «{U}» «{V}» «{hU}» «{hV}»`."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Finish by using `«{h}».isOpen_inter` again. You might need to rewrite using `Set.inter_assoc` and/or `Set.inter_comm`."
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "Level completed!"
msgstr ""

#: Game.Levels.Spaces.L01_spaces
msgid "The `TopologicalSpace` typeclass is defined as follows:\n"
"\n"
"```\n"
"class TopologicalSpace (X : Type u) where\n"
"  protected IsOpen : Set X → Prop\n"
"  protected isOpen_univ : IsOpen univ\n"
"  protected isOpen_inter : ∀ s t, IsOpen s → IsOpen t → IsOpen (s ∩ t)\n"
"  protected isOpen_sUnion : ∀ s, (∀ t ∈ s, IsOpen t) → IsOpen (⋃₀ s)\n"
"```\n"
"\n"
"The `IsOpen` predicate is used to determine whether a set is open in the topological space.\n"
"You can treat it as a function: `IsOpen U` returns `true` if `U` is open and `false` otherwise.\n"
"\n"
"The other three lines are the axioms of a topological space.\n"
"You can treat them as theorems: If `U` and `V` are open set in `X`,\n"
"and you have hypotheses `hU : IsOpen U` and `hV : IsOpen V`,\n"
"then `isOpen_inter hU hV` is a proof of `IsOpen (U ∩ V)`."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "Closed sets"
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "In this level we introduce closed sets.\n"
"In Lean, the predicate `IsClosed` asserts that a set is closed.\n"
"If U is a set in a topological space X, then `IsClosed U` is defined as `IsOpen Uᶜ`,\n"
"where `Uᶜ` is the complement of U.\n"
"\n"
"You can use the theorem `isOpen_compl_iff` to rewrite `IsClosed U` as `IsOpen Uᶜ`, and vice versa."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "Show that if $U$ and $V$ are closed sets in $X$, then $U ∪ V$ is closed."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "In this level, you can use `Set.compl_union` to rewrite ` (U ∪ V)ᶜ` as `Uᶜ ∩ Vᶜ`."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "You can use `rw [← isOpen_compl_iff]` to rewrite `IsClosed U` as `IsOpen Uᶜ`."
msgstr ""

#: Game.Levels.Spaces.L02_closed
msgid "$U^c$ is open if and only if $U$ is closed."
msgstr ""

#: Game.Levels.Spaces
msgid "Spaces"
msgstr ""

#: Game.Levels.Spaces
msgid "This module introduces the basics of topological spaces."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Introduction to continuous functions"
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "In this world, we introduce continuous functions.\n"
"In Lean, the predicate `Continuous` asserts that a function is continuous.\n"
"Given a proposition `h : Continuous f`, you can use `h.isOpen_preimage` to prove that the preimage of an open set is open.\n"
"\n"
"Let's warm up by proving that the continuous preimage of a closed set is closed.\n"
"\n"
"In this level, you can use the theorem `PreimageComplement`, which you proved in the functions world,\n"
"to rewrite `f⁻¹' (Uᶜ)` as `(f⁻¹' U)ᶜ`."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "If $f \\\\colon X \\\\to Y$ and $U \\\\subset Y$ is closed, then $f^{-1}(U)$ is closed."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "As always, start with `intro h`."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Recall the theorem `isOpen_compl_iff`. You can rewrite the statements in terms of open sets by writing `rw [← isOpen_compl_iff]` and `rw [← isOpen_compl_iff] at «{h}»`."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Remember in the functions world, we proved that the preimage of a complement is the complement of the preimage. You can use the theorem in this level, by writing `rw [← PreimageComplement]`."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Now you can use `«{hf}».isOpen_preimage` to finish the proof."
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "Level completed!"
msgstr ""

#: Game.Levels.Continuous.L01_continuous
msgid "The typeclass `Continuous` is defined as follows:\n"
"\n"
"```\n"
"class Continuous {X Y : Type} [TopologicalSpace X] [TopologicalSpace Y] (f : X → Y) where\n"
"  isOpen_preimage : ∀ {U : Set Y}, IsOpen U → IsOpen (f ⁻¹' U)\n"
"```\n"
"\n"
"If you have hypotheses `hf : Continuous f` and `hU : isOpen U`, then `hf.isOpen_preimage U hU` is a proof of `isOpen (f ⁻¹' U)`."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "Composition of continuous functions"
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "In this level, we prove that the composition of continuous functions is continuous.\n"
"\n"
"We introduce the theorem `continuous_def`, which states that a function is continuous if and only if the preimage of every open set is open."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "The composition of continuous functions is continuous."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "In this level, you can use the theorem `continuous_def`, which states that a function is continuous if and only if the preimage of every open set is open. Try using `rw [continuous_def]`."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "In this level, you can use the theorem `PreimageComposition`, which you proved in the functions world."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "Again, you can use `«{hf}».isOpen_preimage` and `«{hg}».isOpen_preimage` to finish the proof."
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "Level completed!"
msgstr ""

#: Game.Levels.Continuous.L02_is_continuous
msgid "A function is continuous if and only if the preimage of every open set is open."
msgstr ""

#: Game.Levels.Continuous
msgid "Continuous functions"
msgstr ""

#: Game.Levels.Continuous
msgid "This module introduces the basics of continuous functions."
msgstr ""

#: Game
msgid "The topology game"
msgstr ""

#: Game
msgid "Welcome to the topology game!\n"
"\n"
"In this game, you learn to work with topological spaces in Lean.\n"
"\n"
"Before playing this game, it is recommended to have at least some knowledge of Lean tactics and sets in Lean.\n"
"You can learn this, for example, by playing the first worlds in the Set Theory Game."
msgstr ""

#: Game
msgid "In this game, you learn to work with topological spaces in Lean.\n"
"\n"
"Before playing this game, it is recommended to have at least some knowledge of Lean tactics and sets in Lean.\n"
"You can learn this, for example, by playing the first worlds in the Set Theory Game."
msgstr ""

#: Game
msgid "Game Template"
msgstr ""

#: Game
msgid "You should use this game as a template for your own game and add your own levels."
msgstr ""
